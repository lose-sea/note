# 友元

友元的目的: 

让一个函数或者类访问另一个中的私有成员

# 友元关键字 friend

# 友元的三种实现

- 全局函数做友元
- 类做友元
- 成员函数做友元

私有属性在类外无法访问

```cpp
class Building {
public: 
    Building() {
        settingRoom = "客厅"; 
        bedroom = "卧室";  
    }
public: 
    string settingRoom; //  客厅
private: 
    string bedroom;  // 卧室
}; 
void test() {
    Building b; 
    cout << b.settingRoom << endl; 
    cout << b.bedroom << endl;  //  无法访问私有内容
}

```

## 全局函数做友元

在类中声明友元函数,表示可以访问本类的私有属性 

```cpp
class Building {
    friend void test();  // 在类中声明
public: 
    Building() {
        settingRoom = "客厅"; 
        bedroom = "卧室";  
    }
public: 
    string settingRoom; //  客厅
private: 
    string bedroom;  // 卧室
}; 
void test() {
    Building b; 
    cout << b.settingRoom << endl; 
    cout << b.bedroom << endl;   // 可以正常访问
}
```

## 类做友元

在类外写成员函数

在类外写构造函数,要标明作用域

```cpp
// 类外写成员函数
Building::Building() {
    settingRoom = "客厅";  
    bedroom = "卧室"; 
}
```

在类中声明作为友元的类,就可以访问本类的私有成员

```cpp
class Building;  // 提前声明
class People {
public: 
    People(); 
    void visit(); // 参观函数,访问Building中的属性 
    Building* building; 
}; 

class Building {  
public: 
    Building(); 
public: 
    string settingRoom; //  客厅
private: 
    string bedroom;  // 卧室
}; 
// 类外写成员函数
Building::Building() {
    settingRoom = "客厅";  
    bedroom = "卧室";  // error  无法访问
}

People::People() {
    building = new Building; 
} 

void People::visit() {
    cout << building->settingRoom << endl; 
    cout << building->bedroom << endl; 
}
```

```cpp
class Building;  // 提前声明
class People {
public: 
    People(); 
    void visit(); // 参观函数,访问Building中的属性 
    Building* building; 
}; 

class Building {  
    // People类 是本类的友元,可以访问本类的私有成员
    **friend class People;**  **
public: 
    Building(); 
public: 
    string settingRoom; //  客厅
private: 
    string bedroom;  // 卧室
}; 
// 类外写成员函数
Building::Building() {
    settingRoom = "客厅";  
    bedroom = "卧室"; 
}

People::People() {
    building = new Building; 
} 

void People::visit() {
    cout << building->settingRoom << endl; 
    cout << building->bedroom << endl; 
}
```

## 成员函数做友元

```cpp
// 成员函数做友元
class Building;  
class People {
public: 
    People(); 
    void visit1();    // 让visit函数可以访问Building中的私有成员 
    void visit2();    // 让visit访问不到Building中的私有成员 
    Building* building;    
};  

class Building { 
    friend void People::visit1();  // 告诉编译器,Poeple类下的visit的成员函数作为本类的友元,可以访问本类的私有成员

public: 
    Building(); 
public: 
    string settingRoom; 
private: 
    string bedRoom; 
};  

Building::Building() {
    settingRoom = "客厅"; 
    bedRoom = "卧室"; 
}   

People::People() {
    building = new Building;   
}  

void People::visit1() {
    cout << building->settingRoom << endl; 
    cout << building->bedRoom << endl; 
}

void People::visit2() {
    cout << building->settingRoom << endl; 
    // cout << building->bedRoom << endl; 
}

void test() {
    People p; 
    p.visit1(); 
} 
```

在类中声明了成员函数,可以访问本类的私有成员

```cpp
class Building { 
    friend void People::visit1();  // 告诉编译器,Poeple类下的visit的成员函数作为本类的友元,可以访问本类的私有成员

public: 
```