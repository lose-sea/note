# 构造函数和析构函数

对象的初始化和清理也是两个非常重要的安全问题

- 一个对象如果没有初始状态,对其使用后果是未知
    
    同样的使用完一个对象或变量,没有及时清理,也会造成一定的安全问题
    

C++中利用了构造函数和析构函数解决上述问题,这两个函数会被编译器自动调用,完成对象的初始化和清理工作

对象的初始化和清理工作是编译器强制要我们做的事情,因此如果我们不提供构造和析构,编译器会提供编译器提供的构造函数和析构函数是空实现

# 构造函数语法   类名() {}

1. 构造函数,没有返回值也不写void
2. 函数名称和类名相同
3. 构造函数可以有参数,因此可以发生重载
4. 程序在调用对象时候会自动调用构造,无需手动调用,而且只会调用一次

# 析构函数语法   ~类名() {}

1. 析构函数,没有返回值也不写void
2. 函数名称与类名相同, 在名称前加上符号~
3. 析构函数不可以有参数,因此不可以发生重载’
4. 程序在对象销毁前会自动调用析构,无需手动调用,而且只会调用一次

```cpp
class Person{
public : 
    Person() {
        cout << "构造函数调用" << endl; 
    }
    ~Person() {
        cout << "析构函数调用" << endl; 
    }
}; 

int main() {
    Person p; // 构造函数调用  析构函数调用
    return 0; 
}
```

构造函数的分类及调用

两种分类方式: 

- 按参数分为: 有参构造和无参构造
    
    按类型分为: 普通构造和拷贝构造
    

三种调用方式 

- 括号法
- 显示法
- 隐式转换法+

构造函数

```cpp
class Person {
public : 
// 无参构造
    Person() {
        cout << "无参构造函数调用" << endl; 
    } 
// 有参构造 
    Person(int n) { 
        age = n; 
        cout << "有参构造函数调用" << endl;  
    } 
// 拷贝构造函数
    Person (const Person& p) { 
        cout << "拷贝构造函数调用" << endl; 
        age = p.age; 
    }
    int age = 0; 
// 析构函数
    ~Person() {
        cout << "析构函数调用" << endl;  
    }
}; 
```

构造函数的调用

括号法

```cpp
    Person p1;  // 默认构造函数的调用 
    Person p2(10);  // 有参构造函数调用 
    Person p3(p2);  // 拷贝构造函数调用 
    cout << p3.age << endl;  // 10
```

调用默认构造函数的时候,不要写(); 

因为下面这行代码,编译器会认为是一个函数的声明,不会认为在创建对象

```cpp
Person p1();
```

显示法

```cpp
    Person p1 = Person(10); // 有参构造函数调用  
    Person p2 = Person(p1); // 拷贝构造函数调用 
```

创建匿名对象

匿名对象特点: 当前行执行结束之后,系统会立即回收掉匿名对象

```cpp
    Person(10);   // 匿名对象
```

注意: 

不要利用拷贝构造函数初始化匿名对象 

编译器会认为Person (p3) == Person p3; 

隐式转换法

```cpp
    Person p = 10;  // 相当于写了 Person p = Person(10); 
```

# 拷贝构造函数的调用时机

C++中拷贝构造函数调用时机通常有三种情况

- 使用一个已经创建完毕的对象来初始化一个新对象
- 值传递的方式给参数传值
- 以值方式返回局部对象

# 构造函数的调用规则

默认条件下C++编译器至少会给一个类添加3个函数

1. 默认构造函数,(无参,函数体为空)
2. 默认析构函数 (无参,函数体为空)
3. 默认拷贝构造函数,对函数进行值拷贝

构造函数调用规则如下: 

- 如果用户定义有参构造函数,C++不再提供默认构造函数,但会提供拷贝构造函数
    
    如果用户定义拷贝构造函数,C++不会再提供其他构造函数
    

# 深拷贝和浅拷贝

浅拷贝: 简单的赋值拷贝操作

深拷贝: 在堆区重新申请空间,进行拷贝操作

**如果利用编译器提供的拷贝构造函数,会做浅拷贝操作**

浅拷贝带来的问题就是堆区的内存重复释放,这是可以用深拷贝进行解决

```cpp
class Person {
public: 
    Person() {
        cout << "默认构造函数调用" << endl; 
    }  
    Person(int n, int h) { 
        age = n; 
        height = new int(h); 
        cout << "有参构造函数调用" << endl; 
    }  
    int age;
    int* height; 
    ~Person() { // 析构代码,将堆区开辟的数据释放 
        if (height != NULL) {
            delete height; 
            height = NULL; 
        }
        cout << "析构函数调用" << endl; 
    } 
}; 
int main() {
    Person p1(18, 160);  
    cout << p1.age << " " << *p1.height << endl;  
    Person p2(p1); 
    cout << p2.age << " " << *p2.height << endl; 
    return 0; 
}
```

自己实现拷贝构造函数,解决浅拷贝带来的问题

```cpp
    //自己实现拷贝构造函数,解决浅拷贝带来的问题
    Person (const Person& p) {
        cout << "有参构造函数调用" << endl; 
        age = p.age; 
        height = p.height;   // 编译器默认实现的就是这行代码
        // 深拷贝操作
        height = new int(*p.height); 
    } 
```

如果属性有在堆区开辟的,一定自己提供拷贝构造函数,防止浅拷贝带来的问题