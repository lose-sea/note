# 字符数组的输入

# memset

---

void* memset(void* ptr, int value, size_t num) ;

参数解释

> ptr – 指针,指向了要设置的内存块的起始位置
> 
> 
> value – 要设置的值
> 
> num – 设置的字节个数
> 

memset 是用来设置内存的,将内存中的值**以字节为单位**设置成想要的内容,需要头文件<cstring>

```c
#include<iostream>
#include<cstring>
using namespace std;
int main() {
    int arr[10];
    memset(arr, 0, sizeof(arr));

    for (int i = 0; i < 10; i++) {
        cout << arr[i] << " ";
    }                       // right

    char str[20] = "Hello, World!";
    memset(str, '*', 5);
    cout << endl << str << endl;  // ***** World! 以字节为单位

    int brr[10] = {1, 2, 3, 4, 5};
    memset(brr, 1, sizeof(brr));
    for (int i = 0; i < 10; i++) {
        cout << brr[i] << " ";
    }                           // error,每个字节都被设置为1，int通常占4个字节，所以每个int变成了0x01010101，即16843009

    return 0;
}

```

```c
    string s = "Hello, World!";
    memset(&s[2], '*', 5);
    cout << endl << s << endl; //He*****World!

```

# memcpy

---

void* memcpy ( void* destination, const void* source, size_t num );

> destination – 目标空间的起始地址
> 
> 
> source – 	源数据空间的起始地址
> 
> num – 		拷贝的数据的**字节**个数
> 

头文件: <cstring>

```c
    int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int brr[10] = {0};
    memcpy(brr, arr, sizeof(arr));
    for (int i = 0; i < 10; i++) {
        cout << brr[i] << " ";
    }                       // 0 1 2 3 4 5 6 7 8 9

```

# 字符串与字符数组

```c
int main() {
    // 字符串初始化
    string str1 = "Hello, World!";
    cout << "字符串 str1: " << str1 << endl;

    // 字符串数组初始化
    vector<string> str2 = {"Apple", "Banana", "Cherry"};
    cout << "字符串数组 str2: ";
    for (const auto& s : str2) {
        cout << s << " ";
    }
    // 字符数组
    char str3[] = "hello world";
    cout << "\\n字符数组 str: " << str3 << endl;         // 末尾自动添加'\\0'

    char str4[] = {'H', 'e', 'l', 'l', 'o'};
    cout << "str4:  "  << str4 << endl;              // error,末尾没有'\\0'
                                                    // 可能输出乱码
    char str5[20] = {'H', 'e', 'l', 'l', 'o'};
    cout << "str5: " << str5 << endl;               // 剩余部分自动添加'\\0'

    return 0;
}

```

‘\0’是字符串结束标志,如果没有‘\0’, 就会打印出乱码

# 字符串的输入

---

scanf

占位符`%s`.从当前第一个非空白字符开始读起, 知道遇到空白字符(空格, 换行, 制表符) 为止

因为%s 的读取不会包含空白字符,所以无法用来读取多个单词,除非多个%s 一起使用,

另外还有个细节,scanf 遇到%s 占位符,会在字符串变量的末尾存储一个`\\0`字符

同时scanf将字符串读入字符数组时,不会检测字符串是否超过了数组长度,所以,储存字符串时,很可能会超过数组的边界,导致预想不到的结果,为了防止这种情况,使用%s占位符时,可以指定读入字符串的最长长度,即写成==%[m]s==,其中[m]时一个整数,表示读取字符串的最大长度,后面的字符将会被丢弃.

```c
int main() {
    char str[5];
    scanf("%s", str);  // helloworld
    cout << "输入的字符串是: " << str << endl;  // helloworld  超过数组长度，可能导致缓冲区溢出

    scanf("%4s", str);  // helloworld
    cout << "输入的字符串是: " << str << endl;  // hell
    return 0;
}

```

---

## 解决字符串包括空格的问题

---

### fgets 和 gets

char* gets (char* str);

char* fgets (char* str, int num, FILE* stream);

1. gets 是从第一个字符开始读取,一直读到'\n’停止,但是不会读取‘\n’,也就是读取到的内容中没有包含‘\n’, 但是会在读取到的内容后面自动加上 ‘\0’;
2. fgets 也是从第一个字符开始读取,最多添加num - 1个字符,最后一个位置给‘\0’, 如果num 的长度是远大于输入字符长度,就会一直读到‘\n’停止,并且会读取‘\n’, 将‘\n’最为读取到内容的一部分,同时在读取到的内容后自动加上‘\0’;
3. fgets 如果输入的字符长度大于str的范围,只会读取num - 1个

```c
    fgets(str, sizeof(str), stdin);  // helloworld
    cout << "输入的字符串是: " << str << endl;  // hell

```

如果使用fgets时,指定的大小超出了数组范围,会造成缓冲区溢出, 即使正常打印,也会造成潜在风险

```c
fgets (str, 80, stdin); // 指定大小超出了数组范围，会造成缓冲区溢出
cout << "输入的字符串是: " << str << endl;  // 即使正常打印，也会造成潜在风险

```

### scanf

scanf函数其实也可以做到读取带有空格的字符串,只是不常见而已,方式是将“%s”改为“%[^\n]s”, 其中在% 和s 之间加上了“[^\n]”, 意思是一直读取,直到遇到‘\n’, 这样即使遇到空格也就不会结束了.

这种方式读取,不会将‘\n’读取进来,但是在读取到字符串的末尾加上‘/0’;

```c
    scanf("%[^\\n]s", str);  // 输入带空格的字符串 hello world
    cout << "输入的字符串是: " << str << endl; // hello world

```

也可以指定其他字符,读取到指定字符即停止读取

```c
scanf("%[^r]s", str); // 输入带r的字符串 hello world
cout << "输入的字符串是: " << str << endl; // hello wo

```

### getchar

使用getchar 逐个字符读取,也是可以读取一个字符串的

`int getchar(void)`

```c
 int i = 0;
    int ch = 0;
    while ((ch = getchar()) != '\\n') {
        str[i] = ch;
        i++;
    }
    cout << "输入的字符串是: " << str << endl;  // hello world
    str[i] = '\\0';  // 添加字符串结束标志

```

注意: 使用gechar时,需要在末尾加上‘\0’;