# 结构体

## **结构体成员函数**

C++中的结构体和C语言结构体的有一个比较大的差异就是C++中的结构体中除了有成员变量之外,还可以包含成员函数

1. C++的结构体会有一些默认的成员函数,比如:构造函数,析构函数等,是编译器默认生成的,如果觉得不合适,也是可以自己显示的定义这些韩式,这些函数都是自动被调用,不需要手动调用
2. 除了默认的成员函数之外,我们可以自己定义一些成员函数,这些成员函数可以有,也可以没有,完全根据自己的需要来添加,
3. 这些成员函数可以直接访问成员变量
4. 成员函数的调用也使用.操作符

```cpp
     // 结构体成员函数
 struct Stu {
     int chinese;
     int math;
     int total;
     // 成员函数
     // 初始化结构体的成员变量
     void init_Stu() {
         chinese = 100;
         math = 90;
         total = chinese + math;
     }
 };
 int main() {
     struct Stu s1;
     s1.init_Stu();
     cout << s1.chinese << endl;   // 100
     cout << s1.math << endl;    // 90
     cout << s1.total << endl;   // 190
     return 0;
 }
```

### **构造函数和析构函数**

---

### 构造函数

构造函数是结构体中默认的成员函数之一,构造函数的主要任务是初始化结构体变量,写了构造函数,就不需要再写其他成员函数来初始化结构体(类)的成员,而且构造函数是在结构变量创建的时候,编译器自动被调用的.

构造函数的特征如下

- 函数名与结构体(类)名相同
- 无返回值
- 构造函数可以重载
- 若未显示定义构造函数,系统会自动生成默认的构造函数

### 析构函数

析构函数是用来完成结构体变量中资源的清理工作,也是结构体中默认的成员函数之一,析构函数在结构体变量销毁的时候,被自动调用

析构函数的特征如下:

- 析构函数名是在结构体(类)名前加上字符‘~’;
- 无参数无返回值类型
- 一个类只能有一个析构函数,若未显示定义析构函数,系统会自动生成默认的析构函数,注意:**析构函数不能重载**

```
 struct Stu {
     string name;
     int age;
     int score;
     // 构造函数
     Stu() {
         name = "张三";
         age = 18;
         score = 100;
     }
 };
 
 int main() {
     struct Stu s1;
     cout << s1.name << endl;   // 张三
     cout << s1.age << endl;     // 18
     cout << s1.score << endl;   // 100
     // 无需调用构造函数，结构体成员变量自动初始化
     return 0;
 }
```

```
 struct Stu {
     string name;
     int age;
     int score;
     // 构造函数
     Stu() {
         cout << "构造函数被调用了！" << endl;
         name = "张三";
         age = 18;
         score = 100;
     }
     ~Stu() {
         cout << "析构函数被调用了！" << endl;
     }
 };
 
 int main() {
     struct Stu s1;
     cout << s1.name << endl;   // 张三
     cout << s1.age << endl;     // 18
     cout << s1.score << endl;   // 100
     // 自动调用析构函数
     return 0;
 }
```

## **排序**

### **sort函数**

```
 // 版本一
 templete <<class RandomAccessIterator>
 void sort ( RandomAccessInterator first, RandomAccessIterator last);
 // void sort (开始位置,结束位置)
 // first: 指向要排序范围的第一个元素之后位置迭代器或者指针
```

```
 // 版本二
 template <class RamdomAccessIterator, class Compare>
 void sort (RandomAccessIterator first, RandomAccessItetator last, Compare comp);
 // void sort (开始位置,结束位置,自定义排序函数)
 // first : 指向要排序范围的第一个元素的迭代器或者指针
 // last : 指向要排序范围的最后一个元素之后位置的迭代器或者指针
 // comp : 是一个比较函数或者函数对象
 
 // 这里开始位置和结束位置,可以是指针,也可以是迭代器
 // 自定义排序函数,可以是函数,也可以是仿函数
```

在默认情况下,sort函数,按升序对给定范围[fiesta, last]中的元素进行排序

sort 函数需要包含头文件<algorithm>

对数组进行排序

```
 int main() {
     int arr[] = {4, 5, 6, 9, 7, 1, 8, 5, 4, 2};
     int sz = sizeof(arr) / sizeof(arr[0]);
     // arr + sz, 跳过sz个元素，到达数组末尾
     sort(arr, arr + sz); // 升序
     for (int i = 0; i < sz; i++) {
         cout << arr[i] << " ";
     }   // 1 2 4 4 5 5 6 7 8 9
     cout << endl;
     return 0;
 }
```

对字符进行排序(按照ASCLL码值)

```
 // 对字符进行排序
 int main() {
     string str = "defxxxabccba";
     sort(str.begin(), str.end()); // 升序
     cout << str << endl; // aabcccdeffxx
     return 0;
 }
```

### **自定义排序**

`void sort (RandomAccessIterator first, RandomAccessItetator last, Compare comp);`

sort第三个参数是一个可选的自定义比较函数,(或者函数对象),用于指定排序的规则,如果不提供这个参数,std::sort默认会使用小于运算符(<)来比较大小,并按照升序排序

这个比较函数,接受两个参数,并返回一个布尔值,如果第一个参数应该排在第二个参数之前,则返回true, 反之则返回false;

### 创建比较函数

```
 bool cmp (int x, int y) {
     return x > y;
 }
 
 int main() {
     int arr[] = {4, 5, 6, 9, 7, 1, 8, 5, 4, 2};
     int sz = sizeof(arr) / sizeof(arr[0]);
     // arr + sz, 跳过sz个元素，到达数组末尾
     sort(arr, arr + sz, cmp);   // 降序
     for (int i = 0; i < sz; i++) {
         cout << arr[i] << " ";
     }   // 9 8 7 6 5 5 4 4 2 1
     cout << endl;
     return 0;
 }
```

### 结构体中重载()运算符 - 仿函数

```
 struct Cmp {
     operator()(int x, int y) {
         return x > y;
     } // 降序
 }cmp;
 int main() {
     int arr[] = {4, 5, 6, 9, 7, 1, 8, 5, 4, 2};
     int sz = sizeof(arr) / sizeof(arr[0]);
     // arr + sz, 跳过sz个元素，到达数组末尾
     sort(arr, arr + sz, cmp);   // 降序
     for (int i = 0; i < sz; i++) {
         cout << arr[i] << " ";
     }   // 9 8 7 6 5 5 4 4 2 1
     cout << endl;
     return 0;
 }
```

**注意：自定义的比较函数的返回类型是bool类型**

### 排序结构体

```
 // 对结构体进行排序
 struct S {
     string name;
     int age;
 };
 // 按照名字进行排序
  bool cmp_s_by_name(struct S s1, struct S s2) {
     return s1.name > s2.name;
  }  // 升序
 int main() {
     struct S arr[20] = {{"zhangsan", 20}, {"lisi", 25}, {"wangwu", 18}};
     int sz = sizeof(arr) / sizeof(arr[0]);
     sort(arr, arr + sz, cmp_s_by_name);
     for (int i = 0; i < sz; i++) {
         cout << arr[i].name << endl;
     }
     return 0;
 }
```

```
 // 对结构体进行排序
 struct S {
     string name;
     int age;
 };
 // 按照年龄进行排序
 bool cmp_s_by_age(struct S s1, struct S s2) {
     return s1.age < s2.age;
 }
 int main() {
     struct S arr[20] = {{"zhangsan", 20}, {"lisi", 25}, {"wangwu", 18}};
     int sz = sizeof(arr) / sizeof(arr[0]);
     sort(arr, arr + sz, cmp_s_by_age);
     for (int i = 0; i < sz; i++) {
         cout << arr[i].name << endl;
     }
     return 0;
 }
```

按照仿函数的方式来写

```
 struct S {
     string name;
     int age;
 };
 // 按照年龄进行排序
 struct Cmp {
     bool operator()(struct S s1, struct S s2) {
         return s1.age < s2.age;
     }
 }cmp;
 int main() {
     struct S arr[20] = {{"zhangsan", 20}, {"lisi", 25}, {"wangwu", 18}};
     int sz = sizeof(arr) / sizeof(arr[0]);
     sort(arr, arr + sz, cmp);
     for (int i = 0; i < sz; i++) {
         cout << arr[i].name << " " << arr[i].age << endl;
     }
     return 0;
 }
```