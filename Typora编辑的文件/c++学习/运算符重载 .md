# 运算符重载

运算符重载的概念: 对已有的运算符重新进行定义,赋予其另一种功能,以适应不同的数据类型 

# 加号运算符的重载

作用: 实现两个自定义类型相加的运算

### 通过成员函数进行重载

```cpp
// 通过成员函数重载+运算符
class Person { 
public: 
    Person operator+(Person p) {
        Person temp; 
        temp.A = this->A + p.A; 
        temp.B = this->B + p.B; 
        return temp; 
    }
    int A; 
    int B; 
}; 
void test() {
    Person p1; 
    p1.A = 10;
    p1.B = 20; 
    Person p2;  
    p2.A = 30; 
    p2.B = 40;  
    Person p3 = p1 + p2;  
    cout << p3.A << " " << p3.B << endl;  // 40 60
} 
```

成员函数重载的本质: 

```cpp
Person p3 = p1.operator+(p2); 
```

### 通过全局函数进行重载

```cpp
// 通过全局函数重载+运算符
class Person { 
public: 
    int A; 
    int B; 
};  
Person operator+(Person p1, Person p2) {
    Person temp; 
    temp.A = p1.A + p2.A; 
    temp.B = p1.B + p2.B; 
    return temp; 
}
void test() {
    Person p1; 
    p1.A = 10;
    p1.B = 20; 
    Person p2;  
    p2.A = 30; 
    p2.B = 40;  
    Person p3 = p1 + p2;  
    cout << p3.A << " " << p3.B << endl;  // 40 60
} 
```

全局函数重载本质调用

```cpp
Person p3 = operator+(p1, p2); 
```

运算符重载也可以发生函数重载

```cpp
Person p3 = p1 + 10; // Person + int
```

```cpp
// 函数重载的版本

class Person { 
public: 
    int A; 
    int B; 
};  
Person operator+(Person p, int x) {
    p.A += x; 
    p.B += x; 
    return p; 
}
void test01() {
    Person p1; 
    p1.A = 10;
    p1.B = 20; 
    Person p2;  
    p2.A = 30; 
    p2.B = 40;  
    Person p3 = p1 + p2;  
    cout << p3.A << " " << p3.B << endl;  // 40 60 
    Person p4 = p1 + 100; 
    cout << p4.A << " " << p4.B << endl;  // 110 120
}  
int main() { 
    test01(); 
    return 0; 
}

```

 对于内置的数据类型的表达式的运算符是不可能改变的 

不要滥用运算符的重载

# 左移运算符的重载

作用: 可以输出用户自定义的数据类型

用成员函数重载左移运算符

 利用成员运算符重载 <<   p.operator(cout);  简化版本为 p << cout;   与本意不符

```cpp
class Person {
public:  
    // // 利用成员运算符重载 <<   p.operator(cout);  简化版本为 p << cout; 
    // void operator<<(cout) { 

    // }
    int A; 
    int B; 
}; 
```

一般不会用成员函数重载左移运算符,因为无法实现cout在左侧, 只能利用全局函数重载左移运算符

```cpp
class Person {
public:  
    int A; 
    int B; 
}; 

void operator<<(ostream& cout, Person& p) {
    cout << p.A << " " << p.B << endl; 
}
 
int main() {
    Person p; 
    p.A = 10; 
    p.B = 20;  
    cout << p;  // 10 20
    return 0; 
} 
```

可以看到,现在可以正常输出对象的属性了,但是

```cpp
    cout << p << endl; // error 
```

就出错了

这是因为重载函数的返回值是void, 无法继续向后调用,这里有一个链式编程思想,如重载函数的返回值是cout, 就可以继续向后调用

重载函数给为

```cpp
ostream& operator<<(ostream& cout, Person& p) {
    cout << p.A << " " << p.B << endl; 
    return cout;  
} 
```

就可以继续继续向后调用了

```cpp
class Person {
public:  
    int A; 
    int B; 
}; 

ostream& operator<<(ostream& cout, Person& p) {
    cout << p.A << " " << p.B << endl; 
    return cout;  
} 
 
int main() {
    Person p; 
    p.A = 10; 
    p.B = 20;  
    cout << p << endl; // 可以正常输出
    return 0;  
} 
```

重载左移运算符配合友元可以输出自定义数据类型

# 递增运算符的重载

作用: 通过重载的递增运算符,实现自己的整型数据

前置++:  先增加再使用

后置++:  先使用再增加

## 重载前置 ++

```cpp
class MyInterger { 
    friend ostream& operator<<(ostream& cout, MyInterger m); 
public: 
    MyInterger() {
        num = 0; 
    }
private: 
    int num; 
}; 

// 重载左移运算符,输出对象 
ostream& operator<<(ostream& cout, MyInterger m) {
    cout << m.num; 
    return cout; 
}
void test01() {
    MyInterger m; 
    cout << ++m << endl;  // error
}  
```

可以看出,当对MyInterger使用 ++ 运算符的时候报错了

通过成员函数进行重载

```cpp
class MyInterger { 
    friend ostream& operator<<(ostream& cout, MyInterger m); 
public: 
    MyInterger() {
        num = 0; 
    } 
    MyInterger& operator++() {
        num++; 
        return *this; 
    }
private: 
    int num; 
}; 
```

返回值为引用的目的是为了一直对同一个数据进行递增操作

如果不返回引用,结果如下

```cpp
public: 
    MyInterger() {
        num = 0; 
    }  
    MyInterger operator++() {
        num++; 
        return *this; 
    }
private: 
    int num; 
}; 
// 重载左移运算符,输出对象 
ostream& operator<<(ostream& cout, MyInterger m) {
    cout << m.num << endl;  
    return cout; 
}
void test01() {
    MyInterger m; 
    cout << ++(++m) << endl;   // 2 
    cout << m << endl;  // 1
}  
```

返回引用的情况

```cpp
public: 
    MyInterger() {
        num = 0; 
    }  
    MyInterger& operator++() {
        num++; 
        return *this; 
    }
private: 
    int num; 
}; 
// 重载左移运算符,输出对象 
ostream& operator<<(ostream& cout, MyInterger m) {
    cout << m.num << endl;  
    return cout; 
}
void test01() {
    MyInterger m; 
    cout << m++ << endl;   // 2 
    cout << m << endl;  // 2
}  
```

## 重载后置 ++

重载后置 ++ ,void operator++(int)  , 再括号内需要写上int, int代表占位参数,可以用于区分前置和后置递增

```cpp
// 重载后置 ++
class MyInterger { 
    friend ostream& operator<<(ostream& cout, MyInterger m); 
public: 
    MyInterger() {
        num = 0; 
    }  
    // 重载后置 ++ ,void operator++(int)  int代表占位参数,可以用于区分前置和后置递增
    void operator++(int) {
        num++; 
    }
private: 
    int num; 
};  
```

后置++为先使用再递增,所以需要先存储原来的值,再返回递增后的值 

重载后置 ++ 返回值为值,不可以返回引用,因为temp为局部变量,不可以返回局部变量的引用

```cpp
class MyInterger { 
    friend ostream& operator<<(ostream& cout, MyInterger m); 
public: 
    MyInterger() {
        num = 0; 
    }  
    // 重载后置 ++ ,void operator++(int)  int代表占位参数,可以用于区分前置和后置递增
    MyInterger operator++(int) { 
        MyInterger temp = *this; 
        num++; 
        return temp; 
    }
private: 
    int num; 
}; 
```

前后递增返回的是引用,后置递增返回的是值

# 重载赋值运算符( = )

C++编译器至少给一个类添加4个函数

- 默认构造函数
- 默认析构函数
- 默认拷贝构造函数
- 赋值运算符 operatro=,对属性进行值拷贝

如果有属性指向堆区, 做赋值操作时也会出现深浅拷贝的问题 

```C++
class Person {
public: 
    Person(int age) {
        m_Age = new int(age); 
    } 
    int *m_Age;  

    ~Person() {
        if (m_Age != NULL) {
            delete m_Age;  
            m_Age = NULL; 
        }
    }

}; 

void test01() {
    Person p1(18);  

    Person p2(20);  

    p1 = p2;  // 指向了同一块内存空间 会造成重复释放
    cout << "p1的年龄为 " << *p1.m_Age << endl; 
    cout << "p2的年龄为 " << *p2.m_Age << endl; 
}  
```

在执行 p1 = p2 后, p1 和 p2 的m_Age 都指向了同一块内存空间, 会造成重复释放

```C++
    Person& operator=(Person& p) {
        // 编译器是提供浅拷贝
        // m_Age = p.m_Age; 

        // 应该先判断是否有属性在堆区, 如果有先释放干净, 然后再深拷贝
        if (m_Age == NULL) {
            delete m_Age; 
            m_Age = NULL;  
        }  

        // 深拷贝
        m_Age = new int(*p.m_Age);  
        return *this; 
    }
}; 
```

进行深拷贝解决堆区内存重复释放的问题

# 重载函数调用运算符

```Java
// 函数调用运算符的重载
class print {
public: 
    // 重载函数调用运算符
    void operator()(string str) {
        cout << str << endl; 
    }
};  

int main() {
    print print; 
    print("hello world"); 
    return 0; 
}
```

类似于函数调用,所以又叫**仿函数**

仿函数非常灵活,没有固定写法

```Java
class ADD {
public : 
    int operator()(int num1, int num2) {
        return num1 + num2; 
    }
}; 

int main() {

    ADD myadd; 
    int ret = myadd(199, 288); 
    cout << ret << endl; 
    // 匿名函数对象
    cout << ADD()(100, 100) << endl;   // 200
    return 0; 
}
```