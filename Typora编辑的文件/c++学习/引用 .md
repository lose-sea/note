# 引用

## 引用的基本使用

作用: 给变量起别名

语法:数据类型 &别名 = 原名

```c
int main() {

	int a = 10;
	int &b = a;
	b = 20;
	cout << a << endl; // 20
	return 0;
}

```

**注意:**

1. 引用必须初始化
2. 引用在初始化之后,不可以改变

```c

int main() {
    int a = 10;
    int b = 20;
    //int &c;     // error 引用必须初始化
    int &c = a;  // 一旦初始化后，就不可以更改
    c = b;      // 这是赋值操作，不是更改引用
    cout <<"a = " << a << endl;  // 20
    cout <<"b = " << b << endl;  // 20
    cout <<"c = " << c << endl;  // 20
    return 0;
}

```

## 引用做函数参数

作用: 函数传参时,可以利用引用的技术让形参修饰实参

优点: 可以简化指针修改实参

举例：交换函数

```c
// 交换函数
// 1 值传递
void mySwap01(int a, int b) {
	int t = a;
	a = b;
	b = t;
}

// 2 地址传递
void mySwap02(int* a, int* b) {
	int t = *a;
	*a = *b;
	*b = t;
}

// 3 引用传递
 void mySwap03(int &a, int &b) {
 	int t = a;
 	a= b;
 	b = t;
 }

int main() {
	int a = 10;
	int b = 20;
	cout << "a = " << a << " " << "b = " << b << endl;
//	mySwap01(a, b);
//	cout << "值传递" << "a = " << a << " " << "b = " << b << endl;
//	mySwap02(&a, &b);
//	cout << "地址传递" << "a = " << a << " " << "b = " << b << endl;
	mySwap03(a, b);
	cout << "引用传递" << "a = " << a << " " << "b = " << b << endl;
	return 0;
}

```

地址传递和引用传递都会改变实参的值

引用做函数的返回值

不要返回局部变量的引用

```c
//引用做函数的返回值
//不要返回局部变量的引用
int& test01() {
	int a = 10;   // 局部变量存放在四区的 栈区
	return a;
}
int main() {
	int &ref = test01();
	cout << ref << endl;  // 第一次正确，是因为编译器做了保留
	cout << ref << endl;   // 第二次错误，因为a的内存已近释放
	return 0;

```

函数的引用可以作为左值

```c
// 函数的调用而可以作为左值
 int& test02() {
 	static int a = 10; // 静态变量，存放在全局区，全局区上的数据在程序结束后系统释放
 	return a;
 }
int main() {
	int &ref = test02();
	cout << ref << endl;     // 10
	cout << ref << endl;    // 10
	test02() = 1000;
	cout << ref << endl;	// 1000
	cout << ref << endl;	// 1000
	return 0;
}

```

```c
 int& test02() {
 	static int a = 10; // 静态变量，存放在全局区，全局区上的数据在程序结束后系统释放
 	return a; 	// 返回的是a的引用
 }

```

函数返回的是a的别名,ref本身是a的别名,可以访问a的地址

如果函数的返回值是引用,这个函数的调用可以作为左值

## 引用的本质

本质：引用的本质是在C++内部实现是以一个指针常量

> 指针常量 ：int* const ref = &a;
> 
> 
> 指针的指向不可以改变
> 
> 常量指针： const int* ref = &a;
> 
> 指针指向的值不可以改变
> 
> 常量指针常量： 指针指向和指向的值都不可以改变
> 

引用的本质就是一个指针常量

引用一旦初始化后，就不可以发生改变

```c
void func(int& ref) {
	ref = 100; // ref是引用，转换为*ref = 100；
}

int main() {
	int a = 10;
	int& ref = a;  // 自动转换为 int* const ref = &a; 指针常量是指针的指向不可以改变，也说明为什么引用不可以更改
	ref = 20; 	// 内部发现ref是引用，自动帮我们转换为*ref = 20；
}

```

## 常量引用

---

作用：常量引用主要用来修饰形参，防止误操作

在函数形参列表最中，可以加const修饰形参，防止形参改变实参

不能直接引用常数

```c
int main() {

//	int a = 0;
//	int &ref = 10; //error	    引用必须引一块合法的空间
	int a = 10;
	const int& ref = 10;   // right
	//  加上const 之后，编译器将代码修改 ，int temp = 10; const int& ref = temp;
	//ref = 20;  // error			加入const之后，变为只读不可以修改
	return 0;
}

```

在以引用的形式传递参数时用const修饰,可以避免对于参数的误操作,不可以再改变实参

```c
void showvalue01(int& value) {
	value = 1000;
	cout << "value = " << value << endl;
}
void showvalue02(const int& value) {
	//value = 1000; 		// 加上const修改之后，就不可以再修改数据了
	cout << "value = " << value << endl;
}
int main() {
	int a = 100;
	int& ref = a;
	showvalue01(ref);   // 100
	// 用引用的形式传递参数 ，在函数中以别名的形式操纵形参，会改变实参的值
	cout << "a = " << a << endl;  // 100
	a = 100;
	return 0;
}

```