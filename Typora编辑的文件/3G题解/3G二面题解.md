# 3G二面题解

---

# A-灵感

### Description

这天，迅风在欣赏某地的美景时，灵感大作，在上午及下午**分别**写下了两篇文章，而且迅风很喜欢数文章的字数。

具体地，如果迅风在下午写下的文章的字数之和**严格大于**他在上午写下的文章的字数之和，则认定他的灵感随着时间的推移越积越多。

现在给出迅风所写的四篇文章的字数，请你回答他的灵感是否随着时间的推移越积越多。

### Input

共一行，包含四个正整数 a,b,c,d*a*,*b*,*c*,*d* 分别表示迅风在上午写下的两篇文章的字数及他在下午写下的两篇文章的字数。

### Output

答案共一行，若迅风的灵感随着时间的推移越积越多，则输出 `Yes`；否则，输出 `No`。



```c
#include<stdio.h>
int main() {
    int a = 0 , b = 0; 
    int c = 0 , d = 0; 
    scanf ("%d %d %d %d", &a, &b, &c, &d); 
    if (a + b < c + d) {
        printf("Yes");
    } else {
        printf("No");
    }
    return 0;
}
```

# B-重聚

小紫和小蓝是一对双胞胎，但是在游乐场里走散了。然而她们有超能力。

当她们分开一段时间后，可以感应对方的位置，让二人重聚——然而如果距离太远，那么感应也无可奈何。

具体地：

- 小紫在分离时间 ≥t1≥*t*1 分钟时开启感应，如果她和小蓝距离不超过 d1*d*1，那么可以感应到小蓝的位置。
- 小蓝在分离时间 ≥t2≥*t*2 分钟时开启感应，如果她和小紫距离不超过 d2*d*2，那么可以感应到小紫的位置。

当双胞胎的一个人能感应到另一个人的位置，就可以行动使得两人重聚。

现在小紫和小蓝已经分离了 t*t* 分钟，当前距离为 d*d*。她们都在原地等候。

请判断至少还需要几分钟，才能让双胞胎中的一个人感应到另一个人的位置？

### 

### 问题分析

这个问题需要分情况讨论

1. d > d1 && d > d2

这种情况下二人永远都无法感应到；

2. d > d2 && d < d1

这种情况下等待时间等于t1 - t（若t1 <= t, 则等待时间等于0）

3. d > d1 && d < d2  

这种情况下等待时间等于t2 - t（若t2 <= t, 则等待时间等于0）

4. d > d1 && d > d2

这种情况下假设二人中时间较短的为min

则等待时间为min - t (若min <= t, 则等待时间等于0)

```c
#include<stdio.h>
int main() {
    int t, d, t1, d1, t2, d2; 
    scanf ("%d %d %d %d %d %d", &t, &d, &t1, &d1, &t2, &d2); 
	int wait_t1 = t1 - t > 0 ? t1 - t : 0;
	int wait_t2 = t2 - t > 0 ? t2 - t : 0;
	int min = wait_t1 > wait_t2 ? wait_t2 : wait_t1; 
	if (d > d1 && d > d2) {
        printf("-1"); 
        return 0;
    } else if (d >= d2 && d <= d1) {
        printf("%d", wait_t1); 
    } else if (d <= d2 && d>= d1) {
        printf("%d", wait_t2); 
    } else {
        printf("%d", min); 
    }
	return 0; 
}
```



# C-求回文数

+++

## 题目描述

一个正整数，正读和反读都相同的数为回文数，例如 $22,131,2442,37073,6,\cdots$。所有的 $1$ 位数都是回文数。

现给出一个正整数 n，求出 $[1,n]$ 中的回文数的个数。

## 输入格式

一个整数 $n$。

## 输出格式

一个整数，即 $1\sim n$ 中全部回文数的个数。



### 分析

首先写一个函数来判断一个数n是否是回文数（palindrome）

如果是一位数就是回文数,直接返回1;

如果是多位数就把它反转,再看它与原来相不相等,相等就返回1,否则返回0;

```c
int Palindrome(int n) {
    if (n <= 9) {
        return 1; 
    }
    int m = n;
    while (m > 0) {
        int re %= 10;     
        int k  = k * 10 + re; 
    }
    if (k == n) {
        return 1;
    }
    return 0; 
}
```

然后从把从1到n的数字遍历一遍,设置一个变量num来计数,符合条件的话就让num++;

完整代码如下

```c
#include<stdio.h>
int Palindrome(int n) {
    if (n < 10) {
        return 1; 
    }
    int m = n; 
    int k = 0;
    while (m > 0) {
        int re = m % 10; 
        k = k * 10 + re;  
        m /= 10;
    }
    if (k == n) {
        return 1;
    }
    return 0;
}
int main() {
    int n;
    scanf("%d", &n);
    int i = 0;
    int num = 0;
    for (i = 1; i <= n; i++) {
        int k = Palindrome(i);
        if (k == 1) {
            num++;
        }
    }
    printf("%d", num); 
    return 0;
}
```



# D-小鱼比可爱

***

## 题目描述

人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度**可能一样**。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。

## 输入格式

第一行输入一个正整数 $n$，表示鱼的数目。

第二行内输入 $n$ 个正整数，用空格间隔，依次表示从左到右每只小鱼的可爱程度 $a_i$。

## 输出格式

一行，输出 $n$ 个整数，用空格间隔，依次表示每只小鱼眼中有多少只鱼不如自己可爱。

## 

## 分析问题

可以用一个数组arr[100]来存储每个小鱼的可爱值；

```c
int arr[123] = {0};
	for (i = 0; i < n; i++) { 
		scanf("%d", &arr[i]); 
	} 
```

然后从第一个小鱼开始遍历,从第一个小鱼数到当前小鱼,用num来计数,再用一个数组brr[100]来存储每个小鱼眼中可爱值低于自己的小鱼个数

```c
int brr[123] = {0}; 
	int num = 0;
	for (i = 0; i < n; i++) {
		for (j = 0; j < i; j++) {
			if (arr[j] < arr[i]) {
				num++; 
			}
		}
		brr[i] = num; 
		num = 0; 
	}
```

完整代码

```c
#include<stdio.h>
int main() {
	int n = 0,i = 0; 
	int j = 0; 
	scanf("%d", &n); 
	int arr[123] = {0};
	for (i = 0; i < n; i++) {
		scanf("%d", &arr[i]); 
	} 
	int brr[123] = {0}; 
	int num = 0;
	for (i = 0; i < n; i++) {
		for (j = 0; j < i; j++) {
			if (arr[j] < arr[i]) {
				num++; 
			}
		}
		brr[i] = num; 
		num = 0; 
	}
	for (i = 0; i < n; i++) {
		printf("%d ", brr[i]);
	}
	return 0; 
} 
```





# E-欢乐的跳

+++

## 题目描述

一个 $n$ 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 $[1,n-1]$ 之间的所有整数，则称之符合“欢乐的跳”，如数组 $\{1,4,2,3\}$ 符合“欢乐的跳”，因为差的绝对值分别为：$3,2,1$。

给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。

## 输入格式

每组测试数据第一行以一个整数 $n(1 \le n \le 1000)$ 开始，接下来 $n$ 个空格隔开的在 $[-10^8,10^8]$ 之间的整数。

## 输出格式

对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出 `Jolly`，否则输出 `Not jolly`。





## 问题分析

先输入一个n个元素的整数数组arr[1000]

```c
int n = 0;
	scanf ("%d", &n);
	int arr[1000] = {0}; 
	int i = 0, j = 0, k = 0; 
	for (i = 0; i < n; i++) {
		scanf("%d", &arr[i]); 
	} 
```



再用一个数组crr[1000]来存储连续元素之间差的绝对值

```c
int crr[1000] = {0}; 
	for (i = 0; i < n; i++) {
		for (j = 0; j < n - 1; j++) {
			crr[i] = abs(arr[i+1] - arr[i]);
		}
	}
```

然后用一个数组brr[1000]来标记出现过的数字,初始化为0,从1开始遍历,如果出现过,就让brr[1000]数组对应下标的位置标记为1

```c
int brr[1000] = {0}; 
	for (i = 1; i < n; i++){
		for (j = 0; j < n; j++) {
			if (i == crr[j]) {
				brr[i] = 1;
				break; 
			}
		}	
	 }
```

最后从1开始遍历,如果有一个数不能从brr[1000]中找到,就直接输出”Not jolly“，然后程序结束，反之如果每一个数都可以从brr[1000]中找到,就输出"Jolly"

```c
for (i = 1; i < n; i++) {
		if (brr[i] == 0) {
			printf("Not jolly\n");
			return 0; 
		}
}
printf("Jolly\n");
```

完整代码如下 

```c
#include<stdio.h>
#include<stdlib.h>
int main() {
	int n = 0;
	scanf("%d", &n);
	int arr[1000] = {0}; 
	int i = 0, j = 0, k = 0; 
	for (i = 0; i < n; i++) {
		scanf ("%d", &arr[i]); 
	} 
	int crr[1000] = {0}; 
	for (i = 0; i < n; i++) {
		for (j = 0; j < n - 1; j++) {
			crr[i] = abs(arr[i + 1] - arr[i]);
		}
	}
	int brr[1000] = {0}; 
	for (i = 1; i < n; i++) {
		for (j = 0; j < n; j++) {
			if (i == crr[j]) {
				brr[i] = 1;
				break; 
			}
		}	
	}
	for (i = 1; i < n; i++) {
		if (brr[i] == 0) {
			printf ("Not jolly\n");
			return 0; 
		}
	}
	printf("Jolly\n");
	return 0; 
} 
```



---



# F - 车厢重组

---

## 题目描述

在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转 $180$ 度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。

## 输入格式

共两行。 

第一行是车厢总数 $N( \le 10000)$。

第二行是 $N$ 个不同的数表示初始的车厢顺序。  
（**注**：实际上数据中并不都在同一行，有可能分行输入）

## 输出格式

一个整数，最少的旋转次数。

## 问题分析

这是一个统计冒泡排序的次数的问题;

可以定义一个变量num来计数,每执行一次就+1;最后输出num 的值;

```c
int num = 0;    
for (int i = 0; i < n - 1; i++) {        
	for (int j = 0; j < n - 1 - i; j++) {            
		if (arr[j] > arr[j + 1]) {                
		int tem = arr[j];                
		arr[j] = arr[j + 1];                
		arr[j + 1] = tem;                
		num++;            
		}        
	}    
}
```

完整代码如下:

```c
#include<stdio.h>
int arr[10001] = {0};
int main() {
    int n = 0;
    scanf("%d", &n);
    for(int i = 0; i < n; i++){
        scanf("%d", &arr[i]);
    }
    int num = 0;
    for(int i = 0; i < n - 1; i++) {
        for(int j = 0; j < n - 1 - i; j++) {
            if(arr[j] > arr[j + 1]) {
                int tem = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tem;
                num++;
            }
        }
    }
    printf("%d", num);
    return 0; 
}
```





# G-笨小猴

## 题目描述

笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！

这种方法的具体描述如下：假设 $\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\text{maxn}-\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。

## 输入格式

一个单词，其中只可能出现小写字母，并且长度小于 $100$。

## 输出格式

共两行，第一行是一个字符串，假设输入的单词是 Lucky Word，那么输出 `Lucky Word`，否则输出 `No Answer`；

第二行是一个整数，如果输入的单词是 Lucky Word，输出 $\text{maxn}-\text{minn}$ 的值，否则输出 $0$。



## 问题分析

---

首先写一个判断质数的函数,如果是质数就返回1,否则返回0; 

```c
int Isprime(int n) {
    if (n < 2) {
		return 0; 
	} 
    if (n == 2) {
		return 1; 
	} 
    if (n % 2 == 0) {
		return 0; 
	}
	int i = 0; 
	for (i = 3; i * i <= n; i += 2) {
		if (n % i == 0) {
			return 0; 
		}	
	}
	return 1; 
}
```





再输入一个字符串,用一个字符数组来存储

```c
char arr[100] = ""; 
	scanf("%s", arr); 
```

然后再创建一个整型数组来统计每个字母出现的次数

```c
int brr[26] = {0}; 
	for (i = 0; i < len; i++) {
		int t = arr[i] - 'a'; 
		brr[t]++; 
	}
```



再对出现过的字母进行计数，找出单词中出现次数最多的字母的出现次数，以及单词中出现次数最少的字母的出现次数

```c
int max = 0, min = 100; 
for (i = 0; i < 26; i++) {
	if (brr[i] != 0) { 
		if (max < brr[i]) {
			max = brr[i]; 
		} 
        if (min > brr[i]) {
			min = brr[i]; 
		}
	}
} 
```



最后再用函数来判断max-min是否是一个质数,输出结果

```c
int diff = max - min; 
if (Isprime(diff)) {
	printf("Lucky Word\n%d\n", diff);
} else {
	printf("No Answer\n0\n"); 
}
```

完整代码如下

```c
#include<stdio.h>
#include<string.h>
int Isprime(int n) {
	if (n < 2) {
		return 0; 
	} 
    if(n == 2) {
		return 1; 
	} 
    if(n % 2 == 0) {
		return 0; 
	}
	int i = 0; 
	for (i = 3; i * i <= n; i += 2) {
		if (n % i == 0) {
			return 0; 
		}	
	}
	return 1; 
}
int main() {
	char arr[100] = ""; 
	scanf ("%s", arr); 
	int len =  strlen(arr);
	int i = 0;  
	int brr[26] = {0}; 
	for (i = 0; i < len; i++) {
		int t = arr[i] - 'a'; 
		brr[t]++; 
	}
	int max = 0, min = 100; 
	for (i = 0; i < 26; i++) {
		if (brr[i] != 0) { 
			if (max < brr[i]) { 
				max = brr[i]; 
			} 
            if (min > brr[i]) {
				min = brr[i]; 
			}
		}
	} 
	int diff = max - min; 
	if (Isprime(diff)) {
		printf("Lucky Word\n%d\n", diff);
	} else {
		printf("No Answer\n0\n"); 
	}
	return 0; 
} 
```



# H- 句子反转

---

## 题目背景

**请尽量在 30min 之内写完题目。这是指「写代码」的时间；「读题」时间不计算在内。**

## 题目描述

给定一行句子，每个词之间用空格隔开，要么是全小写英文单词，要么是全大写英文单词，要么是自然数。

要求将这些单词倒序输出。而且对于每个单词，如果是小写词，应当转为大写；如果是大写词，应当转为小写；如果是自然数，应该倒转输出。

举一个例子：
```plaintext
we choose TO go 2 the 123 moon
```

程序应当输出：
```plaintext
MOON 321 THE 2 GO to CHOOSE WE
```

## 



## 问题分析

---

首先可以写一个函数来反转整个字符串，例如

```c
void reverse(char * s, int start, int end) {
    int i = 0; 
    while (start < end) {
        char tem = s[start]; 
        s[start] = s[end]; 
        s[end] = tem; 
    }
}
```

再写一个函数来判断自然数

```c
int Isnumber(char *s, int start, int end) {
	int i = 0; 
	for (i = start; i < end; i++) {
		if (s[i] > '9' || s[i] < '0') {
			return 0; 
		}
	}
	return 1; 
}
```

然后写一个函数来反转每一个单词,通过指针移动的方式来反转每一个单词,如果遇到自然数就跳过;

```c
void reverse_word(char *s) {
    int len = strlen(s);
    if (len == 0) {
        return;
    }
    reverse(s, 0, len - 1); 
    int start = 0; 
    int i = 0; 
    for (i = 0; i <= len; i++) {
        if (s[i] == ' ' || s[i] == '\0') { 		
			if (Isnumber(s, start, i) == 0) {
				reverse (s, start, i - 1);    
	        	start = i + 1; 
			} else {
				start = i + 1;
			} 			
		}			       	            	
	}
}
```

因为要输入一个句子,所以会包含空格,用fgets来输入; 

```c
 char ch[6001] = "";
    fgets(ch, 6001, stdin);
    ch[strcspn(ch, "\n")] = '\0'; 
```

使用strcspn(char *  str , ‘a’ )可以查找字符串中第一个出现的指定字符集中的字符位置（返回值即该位置索引）。然后将末尾的‘\n’换为‘\0’; 

反转之后再替换字母大小写

```c
int len = strlen(ch); 
reverse_word(ch);
int i = 0; 
for (i = 0; i < len; i++) {
     if (ch[i] >= 'a' && ch[i] <= 'z') {
        ch[i] -= 32;
     } else if (ch[i] >= 'A' && ch[i] <= 'Z') {
    	ch[i] += 32;
	}
}
```

完整代码如下

```c
#include<stdio.h>
#include<string.h> 
void reverse(char* s, int start, int end) {
    while (start < end) {
        char temp = s[start];
        s[start] = s[end];
        s[end] = temp;
        start++;
        end--;
    }
}
int Isnumber(char* s, int start, int end) {
	int i = 0; 
	for (i = start; i < end; i++) {
		if (s[i] > '9' || s[i] < '0') {
			return 0; 
		}
	}
	return 1; 
}
void reverse_word(char *s) {
    int len = strlen(s);
    if (len == 0) {
        return;
    }
    reverse(s, 0, len-1);
    int start = 0;
    int i = 0; 
    for (i = 0; i <= len; i++) {
        if (s[i] == ' ' || s[i] == '\0') { 		
			if (Isnumber(s, start, i) == 0) {
				reverse(s, start, i-1);    
	        	start = i + 1; 
			} else {
				start = i + 1;
			} 			
		}			       	            	
	}
}

int main() {
    char ch[6001] = "";
    fgets(ch, 6001, stdin);
    ch[strcspn(ch, "\n")] = '\0'; 
    int len = strlen(ch); 
    reverse_word(ch);
    int i = 0; 
    for (i = 0; i < len; i++) {
        if (ch[i] >= 'a' && ch[i] <= 'z') {
            ch[i] -= 32;
        } else if (ch[i] >= 'A' && ch[i] <= 'Z') {
        	ch[i] += 32;
		}
    }
    printf("%s", ch);
    return 0;
}

```





