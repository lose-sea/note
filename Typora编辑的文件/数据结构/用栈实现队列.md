# 用栈实现队列

## 方法简介

用两个栈来实现队列，一个用于输入，一个用于输出

因为栈遵循LIFO原则（先进后出）,输入的数据会被反转顺序,

所以用两个栈,就可以将数据的顺序反转过来,从而实现队列的FIFO原则(先进先出).

## 具体实现过程

### 首先定义栈结构,包含数据的数组,栈顶指针以及栈的容量

```c
typedef struct Stack {
	int* data; // 存储数据的数组
	int top;	// 栈顶指针
	int capacity;   // 栈的容量
}Stack; 
```

### 再定义队列结构，包含输入栈和输出栈

```c
typedef struct {
	Stack* in_stack; 
	Stack* out_stack; 
}MyQueue;
```

然后再写出栈的相关操作,为之后对队列进行操作做准备

### 创建栈并初始化

```c
Stack* createStack(int capacity) {
    struct Stack* stack = (Stack*)malloc(sizeof(Stack)); 
    if (stack == NULL) {
        return NULL; 
    } 
    stack->data = (int*)malloc(sizeof(int) * capacity); 
    if (stack->data == NULL) {
        free(stack); 
        return NULL; 
    }
    stack->top = -1; 
    stack->capacity = capacity; 
    return stack; 
}
```

### 检查栈是否为空

指向栈的指针为空或者栈的栈顶指针等于-1(初始为-1)时,栈为空

```c
bool isStackEmpty(Stack* stack) {
    return (stack == NULL || stack->top == -1); 
} 
```

### 检查栈是否已满 

当栈的栈顶指针指向栈的数据数组的最后一位,说明栈已满

```c
bool isFullStack(Stack* stack) {
    return stack->top == stack->capacity - 1; 
}
```

### 入栈操作 

先判断栈是否已满,如果栈已满,就无法再入栈

```c
bool pushStack(Stack* stack, int val) {
	if (isStackFull(stack)) {
		return false; 
	} 
	stack->data[++stack->top] = val; 
	return true; 
}
```

### 元素出栈

先判断栈是否为空,为空则无法出栈,反之将元素加入到栈的数据数组中,栈顶指针向前移动一位

```c
bool popStack(Stack* stack, int* value) {
	if (isStackEmpty(stack)) {
		return false; 
	} 
	*value = stack->data[stack->top]; 
	stack->top--; 
	return true; 
}
```

### 查看栈顶元素

```c
// 查看栈顶元素
bool peekstack(Stack* stack, int* value) {
	if (isStackEmpty(stack)) {
		return false; 
	} 
	*value = stack->data[stack->top]; 
	return true; 
}  
```

### 释放栈内存 

先释放栈中数组的内存，再释放栈结构的内存

```c
void clearStack(Stack* stack) {
    if (stack == NULL) {
        return; 
    } 
    free(stack->data); 
    free(stack); 
}
```

### 创建队列并初始化 

包含两个栈,一个用于输入,一个用于输出

```c
// 创建队列并初始化
MyQueue* CreatemyQueue(int capacity) {
	// 分配队列结构内存
	MyQueue* queue = (MyQueue*)malloc(sizeof(MyQueue)); 
	if (queue == NULL) {
		return NULL; 
	}
	// 创建输入栈(用于入队操作)
	queue->in_stack = createStack(capacity); 
	// 创建输出栈(用于出队操作)
	queue->out_stack = createStack(capacity); 
	return queue; 
}
```

### 判断队列是否为空 

判断输出栈为空且输入栈也为空.

如果输出栈为空但输入栈不为空时,可以将输入栈中的元素压入输出栈中

```c
// 检查队列是否为空
// 输出栈和输入栈都为空
bool isMyQueueEmpty(MyQueue* queue) {
	return isStackEmpty(queue->in_stack) && isStackEmpty(queue->out_stack); 
}
```

###  判断队列是否已满 

这个要判断的标准是输入栈是已满且输出栈不为空

,因为如果输入栈已满但输出栈不为空时是不能将输入栈中的元素压入输出栈中的,会打乱数据的顺序,不符合LIFO原则

```c
// 检查队列是否已满
// 输入栈已满并且输出站不为空 (输入站已满即使输出站又空位也不能插入元素,会打乱元素顺序)
bool isMyQueueFull(MyQueue* queue) {
	return isStackFull(queue->in_stack) && !(isStackEmpty(queue->out_stack)); 
}
```

### 入队操作

```c
bool PushmyQueue(MyQueue* queue, int val) {
	// 如果输入栈满了，检查是否可以转移元素
	if (isStackFull(queue->in_stack)) {
		// 只有输出栈为空时才能转移所有元素
		// 如果输出栈不为空但是又空位,是不能将输入栈的元素转移到输出栈中的,会带乱数据的顺序,队列遵循FIFO,栈遵循LIFO
		if (isStackEmpty(queue->out_stack)) {
			// 转移所有输入栈元素到输出栈
			while (!isStackEmpty(queue->in_stack)) {
				int temp;
				if (popStack(queue->in_stack, &temp)) {
					pushStack(queue->out_stack, temp);
				}
			}
			// 现在输入栈空了，可以入队
			return pushStack(queue->in_stack, val);
		} else {
			// 输出栈不为空，无法转移，队列满
			return false;
		}
	}
	// 输入栈未满，直接入队
	return pushStack(queue->in_stack, val);
}
```

### 出队操作

```c
bool PopmyQueue(MyQueue* queue) {
	// 检查输出栈是否为空
	int value;
	if (isStackEmpty(queue->out_stack)) { 
		// 如果输入栈也为空,就直接返回
		if (isStackEmpty(queue->in_stack)) {
			return false; 
		} else {
	// 输出栈为空,检查输入栈,如果输入栈不为空,将输入栈中的元素全部转移到输出栈
			while (!isStackEmpty(queue->in_stack)) {
			 
				if (popStack(queue->in_stack, &value)) {
					pushStack(queue->out_stack, value); 
				}
			}
		}
		
	} 
	// 输出栈不为空,直接出栈
	popStack(queue->out_stack, &value); 
	return true; 
}
```

### 查看队首元素

先判断队列是否为空

队列不为空,就在判断输出栈是否为空,不为空就直接将输出栈的栈顶元素传给要接受队首元素的指针

如果输出栈为空,就将输入站中的元素全部压入输出栈中,(注意是全部,否则会打乱数据的顺序)

```c
bool PeekMyQueue(MyQueue* queue, int* value) {
	if (isMyQueueEmpty(queue)){
		return false; 
	} 
	if (isStackEmpty(queue->out_stack)) {
		while (!isStackEmpty(queue->in_stack)) {
			popStack(queue->in_stack, value); 
			pushStack(queue->out_stack, *value); 
		}
	}
	*value = queue->out_stack->data[queue->out_stack->top]; 
	printf("队首元素是 %d ", * value);
	return true; 
}
```

### 最后释放队列内存

先释放队列中两个栈的内存,再释放队列结构的内存

```c
void FreeMyQueue(MyQueue* queue) {
	freeStack(queue->in_stack); 
	freeStack(queue->out_stack); 
	free(queue); 
}
```

