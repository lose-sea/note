# 栈

 **栈是限定仅在表尾插入或删除操作的线性表， 因此对栈来说，表尾端有其特殊含义，称为栈顶，相应地 ，表头端称为栈底.不含元素地称为空栈.**

假设S = a~1~, a~2~,a~3~…a~n~, 称a~1~为栈底元素,a~n~为栈顶元素，栈中元素按照a~1~,a~2~…次序进栈,退栈的第一个元素是a~n~.栈的修改是按照后进先出的原则进行的,因此,栈又称为是**后进先出**的线性表.

栈的特点：

+ **LIFO原则：最后进入的的元素最先出去**
+ 单端操作：所有操作都在同一端（栈顶）进行
+ 受限访问：只能访问栈顶元素，不能直接访问中间的元素

栈的主要操作:

+ push - 入栈
+ pop - 出栈
+ peek - 查看栈顶元素
+ isEmpty - 判断栈是否为空
+ isFull - 判断栈是否已满

## 用数组实现栈

创建栈

```c
#define MAX_SIZE 100  // 栈的最大容量
// 栈结构体定义
typedef struct {
    int data[MAX_SIZE]; 
    int top; // 栈顶指针
}
```

初始化栈

将栈顶初始化为-1, 目的是与数组索引从0开始相匹配

```c
void initStack(Stack* s) {
	s->top = -1; // 与数组索引从0开始的特点相匹配
}
```

判断栈是否为空

```c
bool isEmpty(Stack* stack) {
	return stack->top == -1; 
} 
```

判断栈是否已满

```c
bool isFull(Stack* stack) {
	return stack->top == MAX_SIZE; 
}
```

入栈操作

先判断栈是否已满,如果栈已满,则无法向栈中加入新的元素,

```c
bool pop(Stack *stack, int *value) {
    if (isEmpty(stack)) {
        printf("栈为空，无法弹出元素\n");
        return false;
    }
    *value = stack->data[(stack->top)--];
    printf("元素 %d 出栈成功\n", *value);
    return true;
}
```

查看栈顶元素

先判断栈是否为空,如果栈为空,则没有栈顶元素

```c
bool peek(Stack* stack, int* value) { // int* value -- 用于返回栈顶元素的指针
	if (isEmpty(stack)) {
		printf("The stack is rmpty!\n"); 
		return false; 
	}
	*value = stack->data[stack->top]; 
	return true; 
}
```

这里不直接返回栈顶元素,是为了解决栈顶为空的情况

+ 返回0? 但0可能是合法的栈顶元素; 
+ 返回-1?-1也可能是合法的元素:
+ 没有明确的方式表示“操作失败”; 

获取栈中的元素个数

top表示数组的索引从0开始，所以栈中元素的个数 size = top + 1

```c
int size(Stack* stack) {
	return stack->top + 1; 
}
```

打印栈中的内容(从栈顶到栈底) 

```c
void display(Stack* stack) {
	if (isEmpty(stack)) {
		printf("The stack is enpty!\n"); 
		return; 
	}
	printf("栈内容(从栈顶到栈底):\n"); 
	for (int i = stack->top; i >= 0; i--) {
		printf("%d ", stack->data[i]); 
	}
	printf("\n"); 
}
```

## 用链表实现栈

**用链表实现栈可以动态调整大小，不受固定容量的限制**

用链表实现栈时:

+ 栈顶对应链表的头节点
+ 入栈相当于在链表头部插入节点
+ 出栈相当于删除链表的头节点
+ 所有操作都在链表的头部进行,时间复杂度为O(1)

链表节点定义

```c
struct Node{
    int data; 
    struct Node* next; 
}Node; 
```

 栈结构定义

```c
typedef struct Node {
    Node* top; 
    int size; 
}LinkedListStack; 
```

`Node* top;`top是指向栈顶的指针

`size`size是栈的大小

初始化栈

让栈顶的指针空,栈的大小为0

```c
void initStack(LinkedListStack* stack) {
    stack->top = NULL; 
    stack->size = 0; 
}
```

创建栈 (动态内存分配), 并进行初始化

```c
// 创建栈
struct Stack* createStack() {
	struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
	if (stack == NULL) {
		return NULL;
	}
	initStack(stack); 
	return stack; 
};
```



判断栈是否为空

不能仅通过判断栈顶指针是否为空指针来判断栈是否为空,也不能仅通过栈的大小是否为0来判断栈是否为空

还需要判断栈的指针本身是否为空

```c
bool isEmpty(LinkedListStack* stack) {
    return stack->top == NULL; 
}									// error
bool isEmpty(LinkedListStack* stack) {
    return stack->size == 0; 
}  									// error; 
// error, 未检查stack本身是否为空
bool isEmpty(struct Stack* stack) {
	return stack == NULL || stack->top == NULL; 
}					// right
```

入栈操作

通过头插法将元素插入栈顶

```c
bool push(LinkedListStack* stack, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node)); 
    if (newNode == NULL) {
        printf("Memroy allocation failed!\n");
        return false; 
    }
	newNode->data = value; 
    newNode->next = stack->top; 
    stack->top = newNode; 
    stack->size++; 
    printf("元素%d入栈成功!\n", value); 
  	return true; 
}
```

出栈操作

先判断栈是否为空, 如果为空,则不能删除,如果不为空,直接删除栈顶节点,

```c
bool pop(LinkedListStack* stack, int* value) { 
    if (isEmpty(stack)) {
        printf("The stack is empty!\n"); 
        return false; 
    }
    Node* temp = stack->top; 
    *value = temp->data; 
    stack->top = temp->next; 
    stack->size--; 
    free(temp); 
    printf("元素%d出栈成功!\n", *value); 
    return true; 
}
```

查看栈顶元素

用bool类型来判断是否成功查看到栈顶元素,否则如果遇到栈为空的时候,没有明确的方式表示“操作失败”; 

```c
bool peek(LinkedListstack* stack, int* value) {
    if (isEmpty(stack)) {
        printf("The stack is empty!\n"); 
        return false; 
    } 
    *value = stack->top->data; 
    return true; 
}
```

获取栈的大小

```c
int size(LinkedListstack* stack) {
    return stack->size; 
}
```

打印栈的内容

```c
void display(LinkedListStack* stack) {
    if (isEmpty(stack)) {
        printf("The stack is empty!\n"); 
        return; 
    }
    Node* current = stack->top; 
    while (current != NULL) {
        printf("%d ", current->data); 
        current = current->next; 
    }
    printf("栈的大小为%d\n", stack->size); 
}
```

清空栈/销毁栈

从栈顶开始,依次出栈,释放每一个节点的内存,重置栈顶指针和大小计数器

```c
void clearStack(LinkedListStack* stack)  {
    while (!isEmpty(stack)) {
        int value = 0; 
        pop(stack, &value); 
    }
    printf("栈已清空\n"); 
}
```

## 栈的顺序结构初始化-动态内存分配

```c
typedef struct {
	int* data;
	int top;
}Stack;
Stack* initStack() {
	Stack* s = (Stack*)malloc(sizeof(Stack)); 
	s->data = (int*)malloc(sizeof(int) * MAX_SIZE); 
	s->top = -1; // 索引
	return s; 
}
```

