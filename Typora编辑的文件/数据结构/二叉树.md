

# 树的定义

树是由n(n≥0)个节点组成的有限集合，具有以下特性：

- 有一个特殊的节点称为根节点(root)
- 其余节点可分为m(m≥0)个互不相交的有限集合，每个集合本身又是一棵树，称为子树 

# 常用术语

- **节点**：树的基本单位
- **根节点**：没有父节点的节点
- **叶子节点**：没有子节点的节点
- **度**：节点拥有的子树个数
- **深度**：从根节点到该节点的路径长度
- **高度**：从该节点到最远叶子节点的路径长度

# 二叉树实现

二叉树是每个节点最多有两个子树的树结构，通常称为“左子树”和“右子树”  

**二叉搜索树的性质: 左子树所有节点的值 < 根节点的值 < 右节点的值**

## 定义二叉树节点

二叉树节点的数据以及指向左子树和右子树的指针

```c
typedef struct TreeNode {
    int data; 
    struct TreeNode* left; 
    struct TreeNode* right; 
}TreeNode; 
```

## 创建新的节点

```c
TreeNode* creatTreeNode(int data) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode)); 
    if (newNode == NULL) {
        return NULL; 
    } 
    // 对创建的节点进行初始化
    newNode->data = data; 
    newNode->left = NULL; 
    newNode->right = NULL;  
    return newNode; 
}
```

## 二叉树的遍历

### 深度优先遍历   DFS   ()

基本原则: 一条路走到黑, 撞了南墙就回头

#### 前序遍历     (根 -> 左 ->右)

```c
void preorderTraversal(TreeNode* root) {
    if (root == NULL) 
        return ; 
    } 
    printf("%d ", root->data);  // 访问根节点
    preorderTraversal(root->left);  // 遍历左子树
    preorderTraversal(root->right);  // 遍历右子树
}
```

#### 中序遍历  (左 -> 根 -> 右)

```c
void inorderTraversal(TreeNode* root) {
    if (root == NULL) {
        return; 
    } 
    inorderTraversal(root->left); 
    printf("%d ", root->data); 
    inorderTraversal(root->right); 
} 
```

#### 后序遍历 (左 -> 右 -> 根)

```c
void postorderTravel(TreeNode* root) {
    if (root == NULL) {
        return NULL; 
    } 
    postorderTravel(root->left); 
    postorderTravel(root->right); 
    printf("%d ", root->data); 
}
```

**对于二叉搜索树,中序遍历会得到一个升序序列**

### 广度优先遍历   /   层次遍历		BFS

核心思想： 先访问当前节点的所有邻接节点(或子节点), 再依次访问这些邻接节点的邻接节点 

BFS 依赖队列 (先进先出 FIFO) 实现“分层推进”:

1. 队列保证先访问的节点,其邻接节点也先被处理.符合“逐层扩散”逻辑
2. 对比DFS用栈(或递归栈), BFS的队列是区分两者的关键

逐层向下,遍历完每一层的所有节点,然后再遍历下一层

```c
void levelOrderTraversal(TreeNode* root) {
    if (root == NULL) {
        return; 
    } 
    struct TreeNode* queue[1000]; 
    int front = 0; 
    int rear = 0; 

    //  根节点入队 
    queue[rear++] = root; 
    while (front < rear) { 
        // 当前层节点数
        int levelsize = rear - front; 
        for (int i = 0; i < levelsize; i++) {
            // 出队 
            struct TreeNode* node = queue[front++]; 
            printf("%d ", node->data); 
            // 左孩子入队 
            if (node->left != NULL) {
                queue[rear++] = node->left; 
            }  
            // 右孩子入队 
            if (node->right != NULL) {
                queue[rear++] = node->right; 
            }
        }
        printf("\n"); 
    }
}
```

## 插入节点

先判断树是为空

因为二叉搜索树的性质是**左子树所有节点的值 < 根节点的值 < 右子树所有节点的值**,

所以将要插入的值data与根节点的值root->data作比较,

如果要插入的值data的值大于根节点的值,就继续向右子树插入,

如果要插入的值data的值小于根节点的值,就继续向左节点插入

```c
TreeNode* insertBST(TreeNode* root, int data) {
    if (root == NULL) {
        return createTreeNode(data); 
    } 
    if (data < root->data) {
        root->left = insertBST(root->left, data); 
    } else if (data > root->data) {
        root->right = insertBST(root->right, data); 
    }
    return root; 
}
```

## 删除节点

删除节点需要考虑三种情况: 

1. 叶子节点: 直接删除
2. 只有一个子节点: 用其子节点替代它
3. 有两个子节点: 找到其中序遍历的后继节点(右子树中的最小节点)或前驱节点(左子树中的最大节点), 用后继节点的值替换待删除节点的值,然后删除那个后继节点

```c
TreeNode* dalete(TreeNode* root, int key) {
	if (root == NULL) {
		return root; 
	} 
	// 寻找要删除的节点 
	if (key < root->data) {
		root->left = delete(root->left, key); 
	} else if (key > root->data) {
		root->right = delete(root->right, key); 
	} else { 
	// 找到节点，开始处理三种情况
	//case 1 & 2： 没有节点或者只有一个节点  
		if (root->left == NULL) {
			TreeNode* temp = root->right; 
			free(root); 
			return temp; 
		} else if (root->right == NULL) {
			TreeNode* temp = root->left; 
			free(root); 
			return temp; 
		} 
		
	// case 3: 有两个子节点
	// 找到右子树的最小节点（后继节点） 
	TreeNode* temp = root->right; 
		while (temp && temp->left != NULL) {
			temp = temp->left; 
		} 
		// 用后继节点的值替换当前节点的值 
		root->data = temp->data; 
		// 递归删除那个后继节点 
		root->right = deleteBST(root->right, temp->data);  
	}
}
```

## 计算树的深度

递归计算树每一个子树的深度，最后取最大值

```c
int getHeight(TreeNode* root) {
	if (root == NULL) {
		return 0; 
	} 
	int leftHeight = getHeight(root->left); 
	int rightHeight = getHeight(root->rght); 
	return (leftHeight > rightHeight ? leftHeight : leftHeight) + 1; 
} 
```

## 计算节点总数

从根节点开始，每遍历一个节点，数量加一

```c
// 计算节点总数
int countNodes(struct TreeNode* root) {
    if (root == NULL) {
        return 0; 
    } 
    return countNodes(root->left) + countNodes(root->right) + 1; 
}
```

## 销毁二叉树

**必须使用后序遍历: 因为需要先释放子节点才能释放根节点** 

从最底层开始,逐步释放每一个节点的内存

```c
// 销毁二叉树
void destoryTree(TreeNode* root) {
	if (root == NULL) {
		return; 
	} 
	destory(root->left); 
	destory(root->right); 
	free(root); 
} 
```





