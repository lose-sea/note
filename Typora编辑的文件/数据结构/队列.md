# 队列

---

队列是一种**先进先出**的线性数据结构

FIFO原则：先进先出

+ 只能在两端进行操作
+ 先进先出–最先进入的元素最先出去

队尾（rear）:添加元素的位置

队头（front）:删除元素的位置

基本操作

| 操作             | 功能                  |
| ---------------- | --------------------- |
| enqueue(leement) | 入队 — 在队尾添加元素 |
| dequeue()        | 出队 — 从队尾移除元素 |
| peek()           | 查看队头元素          |
| isEmpty()        | 判断队列是否为空      |
| isFull()         | 判断队列是否已满      |

循环队列与普通队列

- **普通数组队列的“假溢出”问题**：
  - 我们有两个指针：`front`（指向队首元素）和 `rear`（指向下一个可以插入元素的位置）。
  - 随着元素不断出队（`front` 后移）和入队（`rear` 后移），`rear` 指针很快就会到达数组的末尾。
  - 此时，即使数组的前面部分（`front` 之前）是空的，我们也无法再插入新元素了，因为 `rear` 已经“到头了”。这种现象被称为“假溢出”。

**循环队列就是为了解决这个问题而设计的。** 它的核心思想是：**将数组在逻辑上视为一个环。** 当指针移动到数组末尾时，再前进一位就会回到数组的开头。

## 用数组实现循环队列

---

### 创建队列

在队列结构体中定义队头指针和队尾指针,便于后续对队列的一系列操作

```c
typedef struct {
	int data[MAX_SIZE] ;
	int front; // 队头指针
	int rear; // 队尾指针
}Queue;
```

### 初始化队列

将队头指针和队尾指针都初始化为0

(队头指针指向队首元素,队尾指针指向下一个要插入元素的位置)

```c
void initQueue(Queue* queue) {
	queue->front = 0; 
	queue->rear = 0; 
}
```

### 判断队列是否为空

若队头指针与队尾指针相等,说明还未向队列中插入元素,队列为空

```c
bool isEmpty(Queue* queue) {
	return queue->front == queue->rear; 
}
```

### 判断队列是否已满

若队列下一个要插入元素的位置是队头,说明队列已满,这样就要牺牲一个存储位置,否则front就等于rear; 无法区分队列为空和队列已满的情况.

```c
bool isFull(Queue* queue) {
	return (queue->rear + 1) % MAX_SIZE == queue->front; 
}
```

`return (queue->rear + 1) % MAX_SIZE == queue->front; ` 在队列中,在队尾指针走到数组末尾的时候, 下一个位置就要回到数组的开头;

假如队尾指针已经走到数组的末尾,但队头指针front的前面还有位置,这种情况下队列是未满的; 这种情况称为“假溢出”. 

也可以通过在结构体中加一个计数器来判断队列是否已满

```c
typedef struct {
	int data[MAX_SIZE]; 
	int front; 
	int rear; 
	int count; 
}Queue;
bool isEmpty(Queue* queue) {
	return queue->count == MAX_SIZE; 
}

```

### 获取队尾元素

```c
bool getrear(Queue* queue, int* value) {
	if (isEmpty(queue)) {
		return false; 
	}
	// 获取真实的队尾位置（rear）的前一个位置
	int lastIndex = (Queue->rear - 1 + MAX_SIZE) % MAX_SIZE; 
    *value = Queue->data[lastIndex]; 
	return true; 
}
```

在循环队列中：

- `rear` 指向下一个可插入的位置（即最后一个元素的下一个位置）
- 要获取最后一个元素，需要将 `rear` 向前移动一位
- 由于是循环队列，需要处理边界情况（当 `rear = 0` 时）

### 获取队列元素个数

```c
int getSize(Queue* queue) {
    return (queue->rear - queue->front + MAX_SIZE) % MAX_SIZE; 
}
```

 如果在结构体中加了技术器,也可以直接返回队列中元素的个数

```c
typedef struct {
	int data[MAX_SIZE]; 
	int front; 
	int rear; 
	int count; 
}Queue;
int getSize(Queue* queue) {
    return queue->count; 
}
```

### 打印队列元素

```c
void printQueue(Queue* queue) {
    if (isEmpty(queue)) {
        printf("队列为空!\n"); 
        return; 
    }
    int i = queue->front; 
    while (i != queue->rear) {
        printf("%d", queue->data[i]); 
      	i = (i + 1) % MAX_SIZE; 
        if (i != queue->rear) {
            printf(" "); 
        }
    }
}
```



## 链表实现队列

---

用链表实现队列比数组更自然，因为：

- 不需要考虑扩容问题（动态增长）
- 没有"假溢出"问题
- 不需要循环处理

### 链表节点以及队列定义

```c
// 链表节点定义
typedef struct ListNode {
	int data; 
	struct ListNode* next; 
}Node;
// 队列定义
typedef struct {
	Node* front; 
	Node* rear; 
	int size; 
}LinkedQueue;
```

### 初始化队列

队列中元素个数为0, 队头指针和队尾指针都为空指针

```c
void initQueue(LinkedQueue* queue) {
    queue->front = NULL; 
    queue->rear = NULL; 
    queue->size = 0; 
}
```

### 判断队列是否为空

队列中元素个数为0,队列为空

```c
bool isEmpty(LinkedQueue* queue) {
	return queue->size == 0; 
}
```

### 入队操作

先创建一个节点，再判断队列是否为空，如果队列为空，则队列的头指针和队尾指针都指向新创建的节点。如果队列不为空，则通过尾插的方式将新节点插入到链表从而实现入队操作。

```c
bool enQueue(LinkedQueue* queue, int value) {
	// 创建新的节点
	struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); 
	if (newNode == NULL) {
		return false;  
	}
	newNode->data = value; 
	newNode->next = NULL; 

	// 如果队列为空，则新插入的节点既是队头节点，又是队尾节点
	if (isEmpty(queue)) {
		queue->front = newNode; 
		queue->rear = newNode; 
	} else {   // 当队列不为空，将新节点通过尾插的方式连接到队尾
		queue->rear->next = newNode; 
		queue->rear = newNode; 
	}
	queue->size++; 
	return true; 
}
```

### 出队操作

队列遵循先进先出的规则,所以出队时最先进入队列的元素先出,

因为入队的时候是按照尾插的方式将元素插入队列中的,所以在出队时链表头部的节点先出,

先用一个指针储存队头元素的值,再更新队头指针,

最后不要忘记释放内存,防止内存泄漏.

```c
bool deQuene(LinkedQueue* queue, int* value) {
	if (isEmpty(queue)) {
		return false; 
	} 
	struct ListNode* current = queue->front; 
	queue->front = queue->front->next; 
	*value = current->data; 
	free(current); 
	printf("元素%d出队成功！\n", *value); 
	queue->size--; 
	return true; 
}
```

### 获取队头元素获取队尾元素

front 是指向队头节点的指针，rear是指向队尾元素的指针，所以要获取队头元素和队尾元素，就可以直接访问front和rear指向的节点的数据

```c
bool getFront(LinkedQueue* queue, int* value) {
    if (isEmpty(queue)) {
        return false; 
    }
    *value = queue->front->data; 
    return true; 
}
```

```c
bool getRear(LinkedQueue* queue, int* value) {
    if (isEmpty(queue)) {
        return false; 
    }
    *value = queue->rear->data; 
    return true; 
}
```

​	

### 清空队列

从队头元素开始，让每个元素依次出队,释放每个节点的内存

```c
void clearQueue(LinkedQueue* queue) {
    int value; 
   while (!isEmpty(queue)) { 
       deQueue(queue, &value); 
   }
}
```

### 销毁队列

先清空队列，再初始化队列

```c
void destoryQueue(LinkedQueue* queue) {
    clearQueue(queue); 
    queue->front = NULL; 
    queue->rear = NULL; 
    queue->size = 0; 
}
```

也可以直接遍历释放每个人节点的内存

```c
void destoryQueue(LinkedQueue* queue) {
    struct ListNode* current = queue->front; 
    while (current != NULL) {
       	struct ListNode* temp = current; 
        current = current->next; 
        free(temp); 
    }
    queue->front = NULL; 
    queue->rear = NULL; 
    queue->size = 0; 
}
```

### 打印队列

先检查队列是否为空，

如果为空，则直接返回，如果不为空，再依次打印

```c
void printQueue(LinkedQueue* queue) {
	if (isEmpty(queue)) {
		printf("队列为空！\n"); 
		return; 
	} 
	struct ListNode* current = queue->front; 
	while (current != NULL) {
		printf("%d ", current->data); 
		if (current->next != NULL) {
			printf(" -> "); 
		}
		current = current->next; 
	}
	printf("\n"); 
}
```

