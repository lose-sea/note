# 二分法

二分查找的时间复杂度是 log n  

# 二分法

## 在一个有序数组中寻找指定元素的索引

### 迭代版本

```c
int binarySearch(int *arr, int sz, int target) {
    int left = 0;
    int right = sz - 1;
    int mid = 0;
    while (left <= right) {
        mid = left + (right - left) / 2;
        if (target == arr[mid]) {
            return mid;
        } else if  (target < arr[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;
}

```

- 向函数中传入一个有序数组,数组的长度,以及目标值;
- 定义数组的最小值的下标 left 和最大值大下标 right （数组总长度 - 1） , 以及数组中间值的下标 mid;
- 将目标值与数组中间值 arr[mid] 作比较, 如果 target < arr[mid]; 则说明数组arr[mid] 后的元素均大于target, 可以排除,所以我们就可以然搜索的范围缩小到 arr[0] 到 arr[mid - 1] ,
- 让mid - 1 等于right, 再在left 到 rigth 的范围进行搜索.
- 反之,如果 target > arr[mid]; 则说明数组arr[mid] 前的元素均小于target, 可以排除,所以我们就可以然搜索的范围缩小到 arr[mid + 1] 到 arr[right] , 让mid + 1 等于left, 再在left 到 rigth 的范围进行搜索.

如果找到目标元素的位置, 就返回目标元素的下标, 如果没有找到,则返回-1; (这里不能返回 0 , 因为目标元素的下标可能是0,如果返回0 就不能确定是否找到目标元素)

### 递归版本

```c
int binarySearchRecursive(int* arr, int left, int right, int target) {
    if (left > right) {
        return -1;
    }
    int mid = left + (right - left) / 2;
    if (target == arr[mid]) {
        return mid;
    } else if (target < arr[mid]) {
        return binarySearchRecursive(arr, left, mid - 1, target);
    } else {
        return binarySearchRecursive(arr, mid + 1, right, target);
    }
}

```

与迭代版本不同的是函数的参数,新增了要数组的左边界和有边界,

1. 如果找到目标值,则返回目标值的下标,;
2. 如果没有 target 小于或者大于数组的中间值, 就更新数组的边界,然后再次调用函数,直到找到目标值,
3. 如果直至数组为空都未找到目标值,则返回 -1;

### 找到第一个等于目标值的索引

```c
int findFirstEqual(int* arr, int sz, int target) {
    int left = 0;
    int right = sz - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (target == arr[mid]) {
            result = mid;
            right = mid - 1;
        } else if (target < arr[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return result;
}

```

当找到目标值时：

1. 记录位置：result = mid
2. 继续向左搜索：right = mid - 1
3. 如果左边还有相同值，会更新为更小的索引
4. 如果左边没有相同值，循环结束，返回最后记录的索引

同理, 如果要查找最后一个等于目标元素的值的下标,则记录位置后向右继续搜索,如果右边还有相同的值,则更新为更大的索引,如果右边没有相同值,则循环结束,返回最后记录的索引.

## 用二分法求平方根的近似值

```c
// 求平方根
double mysqrt(double x, double precision) {
    if (x < 0) {
        return -1;
    }
    if (x == 0 || x== 1) {
        return x;
    } // 对特殊值进行处理
    double left = 0;
    double right = 0;
    if (x < 1) {
        left = x;
        right = 1;
    } else {
        left = 1; // 对x的范围进行判断
        right = x;
    }
    double mid;
    while (right - left > precision) {
        mid = left + (right - left) / 2;
        if (mid * mid == x) {
            return mid;
        } else if (mid * mid > x) {
            right = mid;
        } else {
            left = mid;
        }
    }
    return left + (right - left) / 2; //最后一次边界更新后没有进入循环,mid不是最新的根的值,所以这里不用mid
}

```

1. 用二分法求平方根,先对特殊值进行处理,(负数没有平方根, 1 和 0的平方根是自己本身 )；
2. 再判断数据 x 的范围,如果 x 是大于0小于1的,则 x 的平方根的范围也是在 x 到 1 的范围内;如果 x 是大于1的,则x的算数平方根也是大于1的,并且在1 到 x 的范围内
3. 定义变量mid来保存中间值,这里求中间值不是用(left + right) / 2是为了防止溢出,如果left + right的值超出了int的范围,就会导致溢出.
4. 如果中间值的平方等于x,则说明找到了x的平方根,直接返回mid的值;
5. 如果mid的平方小于x的值,则说明mid的值小于x的平方根,将左边界增加到mid + 1,然后在新的范围内再继续进行二分;
6. 反之,如果mid的平方大于x的值,则说明mid的值大于x的平方根,将右边界缩小到mid - 1,然后再新的范围内再继续进行二分;
7. 最后返回 left + (right - left) / 2的值(最后一次边界更新后没有进入循环,mid不是最新的根的值,所以这里不用mid);