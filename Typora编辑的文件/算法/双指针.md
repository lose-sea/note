# 双指针

# 双指针

---

双指针算法是一种常用的算法技巧，通过使用两个指针在数据结构中协同工作来解决问题。

## 基本概念

### 什么是双指针？

双指针算法使用两个指针（索引）在数组、链表或其他序列结构中遍历，根据特定条件移动指针来解决问题。

### 适用场景

1. **有序数组**的查找问题
2. **链表**中的环检测、中间节点查找
3. **滑动窗口**问题
4. **两数之和**、**三数之和**等问题
5. **合并**两个有序数组/链表

### 双指针的三种主要类型

1. 左右指针(对撞指针)
2. 快慢指针
3. 滑动窗口

## 左右指针

---

两个指针向中间移动

**在有序数列中找两数之和**

使用左右指针在有序数组中查找是否存在两数之和等于目标值(假设是从小到大排列)

```c
int twoSum(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    while (left < right) {
        int sum = arr[left] + arr[right];
        if (sum = target) {
            printf("找到:arr[left] = %d + arr[right] = %d = %d\\n", left, arr[left], right, arr[right], target);
                return 1;
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    printf("未找到和为 %d 的两个大数\\n");
    return 0;
}

```

1. 先定义两个指针分别指向数组的开头和末尾,再定义一个变量 sum 来储存arr[left] + arr[right]的值
2. 再拿sum的值和目标值target的值进行比较,
3. 如果sum的值等于target的值,则表明数组中可以找到和为目标值target两个数;
4. 如果sum的值小于target的值,则让left指针向后移动一位,再进行比较;
5. 如果sum的值大于target的值,则让right指针向前移动一位,再进行比较;
6. 如果直到两个指针相遇都没有找到,则说明数组中不存在两个数之和等于目标值;

## 快慢指针

---

两个指针以不同的速度移动

### 用快慢指针来判断链表是否有环

```c
struct ListNode {
    int data;
    struct ListNode* next;
};
bool hasCycle(struct ListNode* head) {
    if (head == NULL || head->next == NULL) {
        return false;
    }
    struct ListNode* slow = head;
    struct ListNode* fast = head;
    while (slow != fast) {
        if (fast == NULL || fast->next == NULL) {
            return 0;
        }
        slow = slow->next;
        fast = fast->next;
    }
    return 1;
}

```

1. 先判断链表是否为空,如果链表为空或者只要一个节点,则不能成环;
2. 再定义两个结构体指针slow和fast;,让两个指针均指向头节点;
3. 然后快指针fast每次向后移动两个单位, 慢指针slow每次向后移动一个单位;
4. 如果快指针到达链表的末尾,则说明链表无环;
5. 如果快指针和慢指针相遇,就说明链表是有环的;

### 寻找链表的中间节点

```c
// 寻找链表中间节点
struct ListNode* middleNode(struct ListNode* head) {
    struct ListNode* slow = head;
    struct ListNode* fast = head;
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next;
    }
    return slow;
}

```

1. 定义两个指针slow 和 fast, 指向链表的头节点.
2. 让快节点fast每次向后移动两个节点,慢指针slow每次向后移动一个节点;
3. fast的速度是slow的两倍,所以当fast到达链表末尾的时候,是slow

## 滑动窗口指针

---

寻找最长无重复字符子串

```c
int lengthOfLongestSubstring(char* s) {
    int n = strlen(s);
    if (n == 0) {
        return 0;
    }
    int left = 0;				//窗口左边界
    int right = 0;  			// 窗口有边界
    int max_len = 0; 			// 记录最大长度
    int char_set[256] = {0};	// 字符出现次数哈希表 -->记录每个字符在窗口中出现的最大次数
    while (right < n) {
        char_set[s[right]]++;
        while (char_set[s[right]] > 1) {
            char_set[s[left]]--;
            left++;
        }
        max_len = (right - left + 1) > max_len ? (right - left + 1) : max_len;
        right++;
    }
    return max_len;
}

```

1. 先计算字符串的长度n;
2. 如果字符串为空则返回0;
3. 再定义变量left, right,max_len,分别记录数组的左边界，右边界，和无重复字符串的最大长度。
4. 再创建一个数组来统计右边界遍历过的字符,每遍历一个字符,该字符所对应的ASCLL码值下标加一.
5. 如果右边界遍历的某个字符出现了第二次,那就收缩左边界,直到移动重复字符第一次出现的后一个位置,然后更新max_len的值.

寻找最长无重复字符子串

```c
// 滑动窗口指针
// 寻找最长无重复字符子串
int  lengthoflongestSubstring(char* s) {
    int left = 0;
    int right = 0;
    int curlen = 0;
    int maxres = 0;
    int size = strlen(s);
    while (right < size) {
        char temp = s[right];
        for (int i = left; i < right; i++) {
            if (s[i] == temp) {
                left = i + 1;
                curlen = right - left;
                break;
            }
        }
        right++;
        curlen++;
        if (curlen > maxres) {
            maxres = curlen;
        }
    }
    return maxres;
}

```

1. 右边界每向右移动一个,都对该位置的字符进行判断,遍历左边界和右边界之间所有的字符,
2. 如果没有与之重复的,那就让当前的长度加一;
3. 如果有重复的,那就让左边界移动到重复字符所在位置的后一位,然后更新当前字符串的长度.
4. 然后更新最大长度