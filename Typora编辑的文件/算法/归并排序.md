# 归并排序

# 基本思想

归并排序采用分治思想,将一个大问题分解成小问题,然后将小问题的解合并起来得到原问题的解

# 算法步骤:

分解: 

- 将排序的数组从中间分为两个子数组
    
    递归地对左右两个数组进行排序
    
    直到子数组长度为1
    

合并

- 将两个已经排序的子数组合并成一个有序数组
    
    比较两个子数组的元素,按顺序放入临时数组
    
    将临时数组复制回原数组
    

# 递归版本的具体实现

## 合并两个有序数组

创建一个临时数组,来存放排好序的数组

将两个子数组分别从第一个元素开始比较,选择较小的放入临时数组

```cpp
vector<int> temp (right - left + 1); 
    int i = left; 
    int j = mid + 1; 
    int k = 0; 
    // 合并两个有序数组,比较两个数组的元素,选择较小的放入临时数组
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++]; 
        } else {
            temp[k++] = arr[j++]; 
        }
    }
```

如果一个数组已经遍历完,而另一个数组还没有,就将给数组的后面所有元素都拷贝到临时数组

```cpp
// 处理第一个子数组的剩余元素
				while (i <= mid) {
				    temp[k++] = arr[i++]; 
				} 
// 处理第二个子数组的剩余元素
				while (j <= mid) {
				    temp[k++] = arr[j++];
				}  

```

此时临时数组中的元素是已经排好序的,将临时数组中的元素拷贝到原数组中

```cpp
// 将归并好的数据从临时数组中复制回原数组
        for (int p = left; p <= right; p++) {
            arr[p] = temp[p]; 
        }
```

## 将数组不断二分

直到每个子数组只剩一个元素,只有一个元素的数组是一定有序的,再将每一个有序子数组用上面的方法合并

```cpp
// 归并排序主函数(递归实现)
void mergeSort(vector<int>& arr, int left, int right) { 
    // 递归终止条件
    if (left >= right) {
        return; 
    } 
    // 计算中间位置,将数组分为两半
    int mid = left + (right - left) / 2; // 防止整数溢出
    // 递归左半部分
    mergeSort(arr, left, mid); 
    // 递归右半部分
    mergeSort(arr, mid + 1, right);
    // 合并两个已经排好序的子数组 
    merge(arr, left, mid, right);  
} 
```

## 递归版本完整代码实现

```cpp
#include<iostream> 
#include<vector> 
using namespace std; 

// 合并两个有序数组
void merge(vector<int>& arr, int left, int mid, int right) {
    // 创建临时数组存储合并结果,大小为当前区间长度
    vector<int> temp (right - left + 1); 
    int i = left; 
    int j = mid + 1; 
    int k = 0; 
    // 合并两个有序数组,比较两个数组的元素,选择较小的放入临时数组
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++]; 
        } else {
            temp[k++] = arr[j++]; 
        }
    }
    // 如果左半部分还有元素,直接复制
    while (i <= mid) {
        temp[k++] = arr[i++]; 
    } 
    // 如果右半部分还有元素,直接复制
    while (j <= right) {
        temp[k++] = arr[j++];
    }
    // 将临时数组中已排序的元素赋值回原数组
    for (int p = 0; p < k; p++) {
        arr[left + p] = temp[p]; 
    } 
} 
// 归并排序主函数(递归实现)
void mergeSort(vector<int>& arr, int left, int right) { 
    // 递归终止条件
    if (left >= right) {
        return; 
    } 
    // 计算中间位置,将数组分为两半
    int mid = left + (right - left) / 2; // 防止整数溢出
    // 递归左半部分
    mergeSort(arr, left, mid); 
    // 递归右半部分
    mergeSort(arr, mid + 1, right);
    // 合并两个已经排好序的子数组 
    merge(arr, left, mid, right);  
} 

int main() { 
    int n = 0 ; 
    cin >> n; 
    vector<int> arr(n, 0); 
    for (int i = 0; i < n; i++) {
        cin >> arr.at(i); 
    }
    cout << "排序前" << endl; 
    for (int i = 0; i < n; i++) {
        cout << arr.at(i) << " "; 
    } 
    cout << endl; 
    mergeSort(arr, 0, arr.size() - 1); 
    cout << "排序后" << endl; 
    for (int i = 0; i < n; i++) {
        cout << arr.at(i) << " "; 
    } 
    cout << endl; 
    return 0; 
}
```

# 迭代版本的具体实现

创建一个临时数组,来存放排好序的元素, 大小和要排序的数组一致

```cpp
int n = arr.size(); 
vector<int> temp(n);  // 临时数组,用于归并操作 
```

控制子数组的大小size从1开始,每次翻倍

例如

- ,当size为1的时候,将数组中相邻的两组大小为1的两个子数组进行排序合并
- 当size的等于4时,将数组中相邻的两组大小为3的两个子数组进行排序合并

```
for (int left = 0; left < n; left += 2 * size) {
            int mid = min(left + size - 1, n - 1);   // 第一个子数组的右边界
            int right = min(left + 2 * size - 1, n -1);   // 第二个子数组的右边界
```

将两个子数组分别从第一个元素开始比较,选择较小的放入临时数组

```cpp
vector<int> temp (right - left + 1); 
    int i = left; 
    int j = mid + 1; 
    int k = 0; 
    // 合并两个有序数组,比较两个数组的元素,选择较小的放入临时数组
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++]; 
        } else {
            temp[k++] = arr[j++]; 
        }
    }
```

如果一个数组已经遍历完,而另一个数组还没有,就将给数组的后面所有元素都拷贝到临时数组

```cpp
// 处理第一个子数组的剩余元素
				while (i <= mid) {
				    temp[k++] = arr[i++]; 
				} 
// 处理第二个子数组的剩余元素
				while (j <= mid) {
				    temp[k++] = arr[j++];
				}  

```

此时临时数组中的元素是已经排好序的,将临时数组中的元素拷贝到原数组中

```cpp
// 将归并好的数据从临时数组中复制回原数组
        for (int p = left; p <= right; p++) {
            arr[p] = temp[p]; 
        }
```

然后将子数组的大小调整为原来的二倍,再进行以上步骤

## 迭代版本完整代码

```cpp
// 迭代版本
void mergeSort(vector<int>& arr) {
    int n = arr.size(); 
    vector<int> temp(n);  // 临时数组,用于归并操作 
    // 外层循环: 控制归并的子数组大小,从1开始,每次翻倍
    for (int size = 1; size < n; size++) {
        // 中层循环
        for (int left = 0; left < n; left += 2 * size) {
            int mid = min(left + size - 1, n - 1);   // 第一个子数组的右边界
            int right = min(left + 2 * size - 1, n -1);   // 第二个子数组的右边界

            // 合并arr[left, mid] 和 arr[mid + 1, right] 两个有序子数组 
            int i = left;  
            int j = mid + 1;  
            int k = left;  
            // 比较两个子数组的元素,选择小的放入临时数组
            while(i <= mid && j <= right) {
                if (arr[i] <= arr[j]) {
                    temp[k++] = arr[i++]; 
                } else {
                    temp[k++] = arr[j++]; 
                }
            } 

            // 处理第一个子数组的剩余元素
            while (i <= mid) {
                temp[k++] = arr[i++]; 
            } 
            // 处理第二个子数组的剩余元素 
            while (j <= mid) {
                temp[k++] = arr[j++];
            }  
            // 将归并好的数据从临时数组中复制回原数组
            for (int p = left; p <= right; p++) {
                arr[p] = temp[p]; 
            }
        }
    }
```

# 归并排序的特点

1. 稳定性: 相等元素相对位置不变
2. 时间复杂度稳定: 始终为O(n log n) 
3. 适合大数据集: 不受输入数据顺序的影响
4. 适合外部排序: 可以处理无法一次性加载到内存的大文件

缺点: 

1. 空间复杂度高: 需要O(n)的额外空间
2. 不是原地排序: 需要额外的存储空间
3. 递归开销: 对于小数据可能不如简单排序算法