# 算法基本概念

# 算法

## 什么是算法

算法是指解题方案的准确而完整的描述,是一种解决问题的清晰指令,算法代表着用系统的方法描述解决问题的策划机制,也就是说,能够对一定规范的输入,在有限时间内获得要求的输出

简单来说算法就是系列的步骤,用来将输入的数据转化成输出的结果

**算法是可以没有输入的,一定要有输出的,没有输出的算法是没有意义的**

## 算法好坏的度量

算法设计好后,根据算法的设计原理,只要问题规模确定,算法中基本语句的执行次数和需求资源个数基本也就确定了

1. 算法执行所需资源的个数与文体规模 n 有关,因此根据算法执行过程中对空间的消耗来衡量算法的好坏,这是**空间复杂度**
2. 算法中基本语句的执行次数与问题规模 n 有关,因此可以根据算法执行过程中,所有语句被执行的次数之和来衡量算法的好坏,这就是时间复杂度

综上: 时间和空间的消耗情况就是我们度量一个算法好坏的标准,也就是时间复杂度和空间复杂度

## 时间复杂度

### 推导大 O 渐进时间复杂度的规则

1. 时间复杂度函数式 T(N) 中,只保留最高阶项,去掉那些低阶项;
2. 如果最高阶项存在且不是1, 则去掉这个项的常数系数
3. T(N) 中如果没有 N 相关的项, 只有常熟项,用常数 1 取代所有加法常数

### 最优, 最差, 平均时间复杂度

最好情况下的时间复杂度为最好时间复杂度

最坏情况下的时间复杂度为最坏时间复杂度

所有情况的比较之和,除以总次数,为算法的平均情况

无论在竞赛还是在工程中,算法的时间复杂度一般为最差情况,因为最差情况是人对一件事情所能承受的底线

时间复杂度案例:

```cpp
void func(int m, int n) {    for (int i = 0; i < m; i++) {        printf("hehe\n");
    }
    for (int i = 0; i < n; i++) {        pirntf("hello\n");
    }}
```

基本语句`printf("")`总的执行次数为f(m + n) = m + n;

m 和 n 的变化都是影响基本语句执行次数,即 m 和 n 都是问题规模,故时间复杂度为O(m + n),或者可以表示为 O(max(m, n)) .

```cpp
void func(int n) {    int cnt = 1;
    while (cnt < n) {        cnt *= 2;
    }}
```

假设执行次数为 x ,则 2x = n; 因此执行次数: x = log2n

因为当 n 接近无穷大的时候,底数的大小对结果影响不大

因此,一般情况下不管底数是多少都可以省略不写,那么本案例的时间复杂度为 logn;

递归算法的时间复杂度的计算

```cpp
long long fac(int N) {    if (N == 0) {        return 1;
    }
    return fac(n - 1) * N;
}
```

递归算法的时间复杂度求解方式为,单次递归时间 * 总的递归次数

> 注意,这里只是简单的估算方式,递归算法的时间复杂度严谨的计算方法是利用主定理来求得递归算法的时间复杂度
> 

常见的时间复杂度的大小对比：

O(1) < O(logN) < O(N) < O(NlogN) < O(N2) < O(N3) < O(2N) < O(n!)