

# 结构体

---

```c
struct stu{
    char name[20]; 
    int age; 
}s1, s2; 
int main() {
    struct stu s3; 
    return 0; 
}
```

> s1, s2 是全局变量, 上s3是局部变量

### 匿名结构体类型

```c
struct {
    char name[20]; 
    int age; 
}s1; 
int main() { 
    return 0; 
}
```

匿名结构体类型只能用一次



# 数据结构

---

数据在内存中的存储

线性

顺序表

链表

树形

> 二叉树



### 结构体自引用

---

在结构体中包含一个类型为该结构体本身的成员 

```c
// struct Node {
//     int data; 
//     struct Node next; 
// };              // error
```

在结构体中存放下一个结构体的指针

```c
struct Node {
    int data; 
    struct Noda* nest; 
}				//right
```

存放数据–>数据域;

存放指针–>指针域;

```c
typedef struct Node {
    char name[20]; 
    int age;
}* linklist; 
//等价于
typedef struct Node {
    char name[20]; 
    int age;
};
typedef struct Node* linklist;
```

### 结构体初始化

---

```c
struct Point {
    int x; 
    int y; 
}p1 = {3, 5}; //right
struct Score {
    int n;
    char ch; 
}; 
struct Stu {
    char name[20];
    int age;
    struct Score s; 
}; 

int main() {
    struct Point p2 = {8, 5}; 
    struct Stu s1 = {"xinyan", 20, {8, 'x'}}; 
    printf("%s %d %d %c", s1.name, s1.age, s1.s.n, s1.s.ch ); 
    return 0; 
}
```



在设计结构体的时候, 我们即要满足对齐,又要节省空间

可以 让占用内存小的成员尽量集中在一起

```c
struct s1 {
    char c1; 
    int i; 
    char c2; 
}; 
struct s2 {
    char c1; 
    char c2; 
    int i; 
}
```

结构体s1占用内存为12 个字节; 

结构体s2占用内存为 8 个字节; 

#### #pragma() 修改默认对齐数

```c
struct S {
    int i;
    double d;
};
int main() {
    printf("%zu\n", sizeof(struct S)); 
}
```

输出: 16

```c
#pragma pack(4) 				//修改默认对齐数为 4 
struct S {
    int i;
    double d;
};
#pragma pack() 				//恢复到默认对齐数
int main() {
    printf("%u\n", sizeof(struct S)); 
}
```

输出: 12

## 结构体传参

---

```c
struct S {
    int data[1000]; 
    int num; 
}; 
void print1(struct S s) {
    int i = 0; 
    for (i = 0; i < 3; i++) {
        printf("%d ", s.data[i]); 
    }
    printf("%d\n", s.num); 
}               //
void print2(struct S* s) {
    int i = 0; 
    for (i = 0; i < 3; i++) {
        printf("%d ", s->data[i]); 
    }
    printf("%d\n", s->num); 
}
int main() {
    struct S s = { {1, 2, 3}, 100}; 
    print1(s); 
    print2(&s); 
    return 0; 
}
```

优选传址调用

> 函数传参的时候,参数是需要压栈,会有时间和空间上的系统开销. 
>
> 如果传递一个结构体对象的时候, 结构体过大, 参数压栈的系统开销比较大, 所以会导致性能的下降. 