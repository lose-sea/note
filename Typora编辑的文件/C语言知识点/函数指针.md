

# 函数指针

----

数组指针—->指向数组的指针就是数组指针

函数指针—->指向函数的指针就是函数指针

> 返回类型(* 函数名)(参数类型); 

&数组名 –> 取出的是数组的地址

&函数名 –> 取出的是函数的地址

``` c
int Add(int x, int y) {
    return x + y; 
}
int main() {
    int arr[5] = {0}; 
    int (*p)[5] = &arr; //数组指针
    
    printf("%p", &Add); 
    printf("%p", Add); 
    
    int (*pf)(int, int) = &Add; //函数指针
    return 0; 
}
```

对于函数来说,&函数名 和 函数名都是函数的地址; 

```c
int Add(int x, int y) {
    return x + y; 
}
int main() {
    int (*pf)(int, int) = &Add; 
    int ret1 = (*pf)(2, 3); 
    int ret2 = Add(2, 3); 
    int ret3 = pf(2, 3); 
    printf("%d\n", ret1); 
    printf("%d\n", ret2); 
    printf("%d\n", ret3);
    return 0; 
}
```

输出:

```c
5
5
5
```

(* pf)中的 * 可写可不写, 如果要写必须要用 ( ) 括起来; 

```c
int main() {
    ( *(void (*)() )0 )(); 
    return 0; 
}
```

`void(*p)();` 		p是函数指针

`void(*)()`		函数指针类型,  类似于int* , char*

`(void (*)() )0`	强制类型转换

以上代码是一次函数调用,调用的是 0 作为地址处的函数

1. 把 0 强制类型转换成  : 无参, 返回类型为 void 的函数的地址 -–>void (*) () 类型, 
2. 调用 0 地址处的函数

`void(*signal( int, void(*)(int)))(int); `

1. signal 是函数名 , 以上代码是一次函数声明 , 声明的 signal 函数的第一个参数类型是 int , 第二个参数类型是函数指针, 该函数指针指向的函数参数是 int ,返回类型是 void , signal 函数的返回类型也是一个函数指针, 该函数指针指向的函数参数是int, 返回类型是void; 

```c
typete void(* pf_t)(int) ; // 把void(*)(int) 类型重命名为pf_t
void(*signal( int, void(*)(int)))(int);----> pf_t(signal(int, pf_t)); 
```

用函数指针实现简单的计算器功能

```c
int Add(int x, int y) {
    return x + y; 
}

int Sub(int x, int y) {
    return x - y; 
}

int Mul(int x, int y) {
    return x * y; 
}

int Div(int x, int y) {
    return x / y; 
}
void calc(int (*pf)(int, int)) {
    printf("请输入两个操作数：>\n"); 
    int x = 0;
    int y = 0;
    int ret = 0;
    scanf("%d %d", &x, &y); 
    ret = (*pf)(x, y); 
    printf("%d\n", ret); 
    ret = 0; 
}
int  main() {
    int input = 0;  
    printf("*********************\n"); 
    printf("**1 Add*****2 Sub***\n"); 
    printf("**3 Mul*****4 Div****\n");
    printf("******0 break *******\n"); 
    scanf("%d", &input);
    do {
        switch(input) {
            case 1:
                calc(Add); 
                break; 

            case 2:
                calc(Sub); 
                break; 

            case 3:
                calc(Mul); 
                break; 

            case 4:
                calc(Div); 
                break; 
        }
    }while (input != 0); 
    return 0; 
}
```

# 函数指针数组

---

把函数指针放在数组中,就是函数指针数组

```c
int Add(int x, int y) {
    return x + y;
}

int Sub(int x, int y) {
    return x - y;
}

int Mul(int x, int y) {
    return x * y;
}

int Div(int x, int y) {
    return x / y;
}
void calc(int (*pf)(int, int)) {
    printf("请输入两个操作数：>\n");
    int x = 0;
    int y = 0;
    int ret = 0;
    scanf("%d %d", &x, &y);
    ret = (*pf)(x, y);
    printf("%d\n", ret);
    ret = 0;
}
int  main() {
    int input = 0;
    printf("*********************\n");
    printf("**1 Add*****2 Sub***\n");
    printf("**3 Mul*****4 Div****\n");
    printf("******0 break *******\n");
    scanf("%d", &input);
    do {
        switch (input) {
        case 1:
            calc(Add);
            break;

        case 2:
            calc(Sub);
            break;

        case 3:
            calc(Mul);
            break;

        case 4:
            calc(Div);
            break;
        case 0:
            printf("退出\n"); 
            break; 

        default:
            printf("输入错误，请重新输入：\n"); 
            break; 
        }
    } while (input != 0);
    return 0;
}
```

`int (*pf)(int, int) = Add; ` 函数指针;

`int (*arr[4]) = {Add, Sub, Mul, Div}; ` 函数指针数组;

```c
int Add(int x, int y) {
    return x + y; 
}

int Sub(int x, int y) {
    return x - y; 
}

int Mul(int x, int y) {
    return x * y; 
}

int Div(int x, int y) {
    return x / y; 
}
int main()  {
    int (*arr[5])(int, int) = {0, Add, Sub, Mul, Div};
    int input = 0; 
    do {
        printf("*********************\n");
        printf("**1 Add*****2 Sub***\n");
        printf("**3 Mul*****4 Div****\n");
        printf("******0 break *******\n");
        scanf("%d", &input);
        if (input == 0) {
            printf("退出\n"); 
        } else if (input >= 1 && input <= 4) {
                printf("请输入两个操作数：>\n");
                int x = 0;
                int y = 0;
                int ret = 0;
                scanf("%d %d", &x, &y);
                ret = arr[input](x, y); 
                printf("%d\n", ret); 
        } else {
            printf("输入错误\n"); 
        }
    } while (input != 0); 
    return 0; 
}
```

# 指向函数指针数组的指针

---

指向函数指针数组的指针是一个指针

指针指向一个数组, 数组的元素都是函数指针;

```c
int main() {
    //函数指针数组
    int (*arr[5])(int, int) = {0, Add, Sub, Mul, Div}; 
    
    //指向函数指针数组的指针
    int (*(*pfarr)[5])(int, int) = &arr; 
}
```

`int (*arr[5])(int, int) = {0, Add, Sub, Mul, Div}; ` 函数指针数组

`int (*(*pfarr)[5])(int, int) = &arr; ` 指向函数指针数组的指针

# 回调函数

---



> 回调函数就是一个通过函数指针调用的函数. 如果把函数的指针(地址)作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。





# qsort 函数

---

**可以排序任意类型的数据**

## 参数说明

void qsort ( ==void* base==, ==size_t num== , ==size_t width==,  ==int (* compare)(const void* eleml==,   ==const void* elem2==)); 

 `void* base` 要排序的数据的起始位置

`size_t num` 待排序的数据的元素的个数

`size_t width` 待排序的数据的大小 (单位是字节)

`int (_cdecl* compare)(const void* eleml,   const void* elem2)` 函数指针—-比较函数

cmp 函数

int (_cdecl* compare)(const void* eleml,   const void* elem2)

elem1–>指向要比较的第一个元素, 

elem2–>指向要比较的第二个函数. 

==void* 类型的指针不能直接进行解引用操作==  void* 是无具体类型的指针, 可以接收任意类型的指针, 按不能进行解引用操作, 也不能 +- 整数,

## 用qsort排序整型数组

```c
int cmp(const void* e1, const void* e2) {
    return *(int*)e1 - *(int*)e2; //void*类型不能解引用, 进行强制类型转换
}
int main() {
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; 
    int sz = sizeof(arr) / sizeof(arr[0]); 
    qsort(arr, sz, sizeof(arr[0]), cmp); 
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]); 
    }
    return 0;
}
```

## 用qsort排序结构体

```c
struct stu{
    char name[20];
    int age; 
};
int cmp_by_name(const void* e1, const void* e2) {
    int ret = strcmp(((struct stu*)e1)->name, ((struct stu*)e2)->name); 
    return ret; 
}

int main() {
    struct stu s[3] = {{"zhang", 20}, {"xin", 19}, {"yan", 18}}; 
    qsort(s, sizeof(s) / sizeof(s[0]), sizeof(s[0]), cmp_by_name); 
    for(int i = 0; i < 3; i++) {
        printf("%s %d\n", s[i].name,s[i].age); 
    }
    return 0; 
}
```

## 模拟实现

---



```c
//比较
int cmp (const void* e1, const void* e2) {
    return *(int*)e1 - *(int*)e2; 
}
//  交换
void swap(char* buf1, char* buf2, int width) {
    for (int i = 0; i < width; i++) {
        char tem = *buf1; 
        *buf1 = *buf2; 
        *buf2 = tem;  
        buf1++;
        buf2++;
    }
}
//sqort 模拟实现
void bubble(void* base, size_t sz, size_t width, int (*cmp)(const void* e1, const void* e2)) {
    size_t i = 0;  
    for (i = 0; i < sz - 1; i++) {
        int flag = 0;
        size_t j = 0; 
        for (j = 0; j < sz - 1 - i; j++) {
            if (cmp ((char*)base + j * width, (char*)base + (j + 1) * width) > 0) {
                swap((char*)base + j * width, (char*)base + (j + 1) * width, width);
                flag = 1;  
            }
        }
        if (flag == 0) {
            break; 
        }
    }
}

int main() {
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; 
    bubble(arr, sizeof(arr) / sizeof(arr[0]), sizeof(arr[0]), cmp); 
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]); 
    }
    return 0;
}
```



