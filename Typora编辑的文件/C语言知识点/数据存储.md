## 原码，反码，补码

正数的原码，反码，补码相同；

负数的反码等于原码符号位不变，其他位按位取反；

负数的补码等于反码加1；

## 栈区

---



栈区内存的使用习惯是先使用高地址处的空间，再使用低地址处的空间。  

数组随着下标的增长地址是由低到高变化的.  

如果i 与 arr 之间有适当的空间,利用数组的越界操作就可能会覆盖到 i , 就可能会导致死循环出现, 从而陷入死循环

```c
int main() {
	int i = 0; 
	int arr[9] = {0}; 
	for (i = 0; i < 12; i++) {
		arr[i] = 1; 
		printf("%d", arr[i]); 
	}
	return 0; 
}
```



## 数据类型

---

#### 整型家族

+ char    [字符的本质是ASCLL码值，是整型，所以划分到整型家族]
  + unsigned char
  + signed char

- chort
  + unsigned short
  + signed short

+ int 
  + unsigned int
  + signed int

+ long
  + unsigned long
  + signed long

##### char到底是signed char 还是unsigned char 标准是未定的，取决于编译器



### 浮点数家族

---

浮点数家族: 只要是表示小数就可以使用浮点型

float 的精度低,存储的属猪范围较小,double的精度更高,存储的数据的范围更大

### 构造类型

----

+ 数组类型
+ 结构体类型    struct
+ 枚举类型        enum
+ 联合类型        union



### 指针类型

---

+ int *pi; 
+ char *pc; 
+ float *pf; 
+ void *pv; 

### 空类型

-----

void 表示空类型 (无类型)

通常用于函数的返回类型, 函数的参数, 指针类型. 

```c
void test (void) {
    printf("test\n"); 
}
int main() {
    test(); 
    return 0; 
}
```

第一个 void 表示 函数无返回值, 第二个 void 表示函数不需要传任何参数



## 整数在内存中的存储

----

数值有不同的表示形式

+ 2进制  
+ 8进制
+ 10进制
+ 16进制

整数的二进制表示有 3 中形式, 分别为原码，反码，补码 

三种表示方式均有符号位和数值位两部分， 符号位用 0 表示 正， 用 1 表示 负； 

> 正整数的原码，反码，补码相同；

> 负数的反码等于原码符号位不变，其他位按位取反； 

> 负数的补码等于反码加1；

整数在内存中存放的是补码的二进制序列； 

##### 大小端：

把一个数据的高位字节序的内容放在低地址处， 把低位字节序的内容放在高地址处， 就是大端字节序存储 ； 

把一个数据的高位字节序的内容放在高地址处， 把低位字节序的内容放在低地址处， 就是大端字节序存储 ； 

 例如：

```c
int a = 20; 
```

内存中存储

```c
14 00 00 00
```

20补码

```c
0000 0000 0000 0000 0000 0000 0001 0100
 0     0   0     0    0   0     1   4
```

所以20的 16 进制是 00 00 00 14

大端存储

```c
00 00 00 14
    
存储数据:   00000000 00000000 00000000 00010100
十六进制:     0x00     0x00     0x00     0x14
```

小端存储

```c
14 00 00 00
    
存储数据:   00010100 00000000 00000000 00000000
十六进制:     0x14     0x00     0x00     0x00
```

==大多数环境下都是小端字节序存储==

检查是什么样的存储方式

```c
#include<stdio.h>
int Check(void) {
	int a = 1; 
	return *(char*)&a; 
}
int main() {
	int a = 1; 
	if (Check()) {
		printf("小端\n");
	}
	else {
		printf("大端\n"); 
	}
	return 0;
}
```

 ```c
  整型 1 的二进制为 00000000 00000000 00000000 00000001
      16进制	      00         00		00		01
 ```

如果为小端序存储 则输出  1 ; 反之则输出 0 ; 



## 浮点数在内存中的存储

 v = (-1)^s  *  M  *  2^E

```c
9.5f  =1001.1
      =1.0011 * 2^3
      =(-1) * 0 * 1.0011 *2^3
```

S  = 0;      M = 1.0011      E = 3

IEEE 754 标准规定:

- 符号位 S:1位,0表示正数,1表示负数
- 指数位 E:8位(float)或11位(double),采用偏移量表示法
- 1 ≤ M < 2
  
    E 位一个无符号整数
    
    对于指数E,如果float类型,E为8位,取值范围为0~255; 如果为double类型,E为11位,取值范围为0~2047. 但是,我们知道,科学计数法中E是可以出现负值的,所以规定,存入内存是E 的真实值必须再加上一个中间数,对于8位的E,中间数是127,对于11位的E,中间值是1023
    
    比如2^10的E是10,所以保存位32位浮点数的时候,必须保存成10 + 127 = 137,即为10001001
    
    V = 0.5 f
    
       = 0.1
    
       = 1.0 * 2 ^-1
    
       = (-1) ^0 * 1.0 * 2^-1
    
    S = 0    M = 1.0  E = -1
    

float类型中,E（真实值）+ 127（中间值）—→126—>存储

double—→E（真实值）+ 1023（中间值)—→1022—>存储

对于32位的浮点数，最高的1位是符号位，即S的值，接下来的8位是指数E，剩下的23位为有效数字M，位数不够32位在后面补0

例如

- float f = 5.5
  
    5.5
    
    101.1
    
    1.011 * 2^2
    
    s = 0   m = 1   e = 2
    

e 的存储值为 2 + 127 = 129

0 10000001  011 00000000000000000000

存储为0100 0000 1011 0000 0000 0000 0000 0000

        4   0     b    0     0   0    0    0

40 b0 00 00
