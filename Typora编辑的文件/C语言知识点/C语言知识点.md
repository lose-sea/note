

## 机器语言 汇编语言 和高级语言

---

机器语言
特点：是计算机能直接识别和执行的语言，由二进制代码（0 和 1）组成。
优点：执行效率极高，因为不需要翻译，直接被硬件执行。
缺点：可读性极差，人类很难理解和编写；可移植性差，不同类型的计算机（如不同架构的 CPU）机器语言不同。
汇编语言
特点：用助记符（如 MOV 表示数据传送，ADD 表示加法等）来代替机器语言中的二进制指令，是一种低级语言，与机器硬件密切相关。
优点：比机器语言易读、易写、易修改；执行效率也比较高，接近机器语言。
缺点：可读性还是不如高级语言，学习难度较大；可移植性差，不同计算机架构的汇编语言差异大。
高级语言
特点：语法更接近自然语言（如英语）和数学表达式，屏蔽了计算机底层的硬件细节，是一种面向问题或面向过程 / 对象的语言。
优点：可读性好，容易学习和使用；可移植性强，同一段高级语言代码，在不同的计算机系统上，经过相应的编译器或解释器处理后，一般都能运行。
缺点：执行效率比机器语言和汇编语言低，因为需要经过编译或解释才能被计算机执行。

----



## C语言函数参数的求值顺序

C语言函数参数的求值顺序是从右向左的，这是语言标准规定的。



---



## 浮点数精度问题

---

浮点数在计算机中的存储是基于二进制的科学计数法。
float类型通常使用 32 位来表示，其中 1 位是符号位，8 位是指数位，23 位是尾数位。
double类型通常使用 64 位来表示，其中 1 位是符号位，11 位是指数位，52 位是尾数位。
由于精度的不同，即使在数学上两个数相等，但在计算机中以浮点数形式存储时
，可能会因为精度的截断和近似表示而变得不相等。



##  const

---

const 是用于声明常量的关键字，具有以下特点：
 块级作用域：与 let 类似，const 声明的变量只在当前代码块内有效
 不可重新赋值：一旦声明并赋值后，就不能再被重新赋值
 必须初始化：声明时必须同时赋值，不能只声明不赋值
 并非绝对常量：对于对象和数组，const 只是保证变量引用不变，但可以修改其内部属性或元素

## 指针

---

sizeof是操作符；
strlen是库函数；
指针无论类型，都是4个字节；
"abc"=="abcde" 这样写下是在比较两个字符串的地址；
两个字符串比较相等应该用strcmp；
%c前加上空格，跳过下一个字符之前的所有字符 ；
pow(  ,  )次方，产生的值是double类型；
指针是内存中一个最小单元的标号，也就是地址；
口头语中指针是指指针变量，用来存放地址；
指针变量：里面存放的是地址，二通过这个地址，就可以找到一个内存单元。
一个小的单元是1个字节 
char 1byte
int  	4byte
bit  	 *8
byte 	 *1024
kb		 *1024
mb
gb
...
x86---32位
x64----64位
NULL---空指针；本质是 0； 
char*p=NULL;
int*k=NULL;
sizeof返回值的类型是无符号整型---unsigned int;  %u; %zu;
sizeof返回值用%zu来打印最准确；
指针大小在32位环境下是8个字节，在64位环境下是8个字节；
指针类型决定解被引用操作访问的是几个字节；int*访问4个，char*访问1个；
double* 访问8个；
指针类型决定了指针+-1操作的是时候，跳过几个字节； 
int *p;*p=10;
p没有初始化，就意味这没有明确指向；
一个局部变量不初始化，放的是随机值；
*p=10;---非法访问内存了，这里的p就是野指针；
野指针的成因：
   局部变量指针未初始化，默认为随机值
   当指针p指向的范围超出数组arr的范围时，p就是野指针 
 int*p=NULL
 //*p=100---err
 if(p3!=NULL)
{
 	*p=100;---OK
} 
*p++=0-->*p=0,p++;
指针-指针得到的是指针之间元素的个数  
&arr[9]-&arr[0]=9;
&arr[0]-&arr[9]=-9;
不是所有的指针都能相减，指向同一块空间的2个指针才能相减；
int arr[10]={0};
char ch[10]={0};
char[5]-arr[3]----无意义err 
数组中随着下标的增长地址由低到高变化；
允许指向数组的指针与指向数组最后一个元素
后面的那个内存位置的指针比较，但是不允许与
指向第一个元素之前的那个内存位置的指针进行比较；
数组：一组相同类型元素的集合 
二级指针解引用 **pa 
int a=5;int * pa=&a----*是指pa是一个指针变量，
int是指pa指向的a的类型是int型
二级指针变量是用来存放一级指针变量的地址；
存放指针的数组就是指针数组；

## malloc和calloc

---

在 C 语言中，static 关键字具有多种作用，主要用于修饰变量和函数，以下是详细介绍：
修饰局部变量
特性
延长生命周期：普通局部变量存储在栈区，在函数调用时分配内存，函数结束时内存被释放，变量值消失。
而被 static 修饰的局部变量存储在静态存储区，在程序运行期间一直存在，不会因为函数调用结束而销毁 。
只初始化一次：在第一次进入函数时，对静态局部变量进行初始化，后续再次调用该函数时，
不再进行初始化，而是保留上一次函数调用结束时的值。
 修饰全局变量
特性
限制作用域：全局变量默认具有外部链接属性，在整个程序中（不同的源文件）都可以通过 extern 声明来访问。当用 static 修饰全局变量时，
它的作用域被限制在定义它的源文件内，其他源文件无法通过 extern 声明来访问该变量，从而避免了不同源文件中同名全局变量的冲突。
修饰函数
特性
限制作用域：被 static 修饰的函数只能在定义它的源文件中被调用，其他源文件无法通过 extern 声明来调用该函数，
从而实现了对函数的隐藏，减少了不同源文件之间函数命名冲突的可能性 。

## 数组名与指针

---

数组名
数组名是一个常量，表示整个数组的首地址。它代表了一组相同类型元素的集合，在内存中占据连续的存储空间。例如int a[5];，a就是数组名。
数组名在定义后不能被重新赋值，因为它是一个常量。
指针
指针是一个变量，其值为另一个变量的地址。它可以指向不同的内存地址，并且可以被重新赋值。例如int *p;，p就是一个指针变量。
二、内存分配
数组名
数组在定义时，编译器会根据数组的大小分配一块连续的内存空间。例如int a[5];会分配 20 字节（假设int为 4 字节）的连续内存。
数组名本身不占用额外的内存空间，它只是指向数组首元素的地址。
指针
指针变量本身在内存中占用一定的空间（通常在 32 位系统中为 4 字节，64 位系统中为 8 字节）。
指针变量可以指向任何类型的变量（只要类型匹配），并且可以通过赋值操作指向不同的内存地址。
三、运算
数组名
数组名在大多数情况下等同于指向数组首元素的指针常量。例如a和&a[0]是等价的。
但是，数组名不能进行自增、自减等赋值操作，因为它是常量。例如a++是非法的。
指针
指针变量可以进行自增、自减、赋值等操作。例如p++是合法的，它会使指针指向下一个元素（如果是指向数组元素的指针）。
指针可以进行算术运算，如p + 1会使指针指向当前地址的下一个元素的地址（取决于指针所指向的数据类型的大小）。
四、作为函数参数
数组名
当数组名作为函数参数传递时，实际上传递的是数组的首地址，函数内部对数组元素的操作会影响到原始数组。例如：

void func(int arr[], int size) {
    // 这里的arr实际上是一个指针
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

### 数组名之所以被称为 “常量指针”，

是因为：它在大多数情况下会隐式转换为指向数组首元素的指针；
这个指针的值（指向的地址）是固定的，不能被重新赋值
（类似 const 修饰的指针）。


当数组名出现在表达式中时（除少数例外情况），会自动转换为指向数组首元素的指针


数组名转换后的指针是常量指针（指针本身的值不可修改），即不能通过数组名改变其指向的地址。

## 指针

当指针作为函数参数传递时，传递的是指针变量的值（即地址），函数内部可以通过该指针访问和修改所指向的变量。例如：

void func(int *p) {
    *p *= 2;
}

综上所述，数组名和指针虽然在某些情况下表现相似，但它们在概念、内存分配、运算和函数参数传递等方面存在明显的区别。





## atoi函数

---

atoi 的使用示例

```c
#include <stdio.h>
#include <stdlib.h> int main() {
    printf("%d\n", atoi("123"));     // 输出: 123
    printf("%d\n", atoi("45.6"));    // 输出: 45（遇到小数点停止）
    printf("%d\n", atoi("78abc"));   // 输出: 78（遇到字母停止）
    printf("%d\n", atoi("  -123"));  // 输出: -123（能处理空格和负号）
    printf("%d\n", atoi("hello"));   // 输出: 0（没有数字返回0）
return 0; 
}
```



## strchr 函数

---

strchr 函数原型

`char *strchr(const char *str, int c);`

参数：
 str：要搜索的字符串
 c：要查找的字符（以int形式传递，但会被转换为char）
返回值：
 找到：返回字符第一次出现的地址（指针）
没找到：返回 NULL
头文件：#include <string.h>

```c
#include <stdio.h>
#include <string.h>

int main() {
    const char *str = "I love C programming!";
    // 直接传递字符 'C'，C 自动转为其 ASCII 码 67（int 类型）
    char *result = strchr(str, 'C'); 
    
    if (result != NULL) {
        printf("找到 'C'，位置：%ld\n", result - str); // 输出：找到 'C'，位置：7
    }
    return 0;
}
```



数组名通常表示的都是数组首元素的地址
但有两个特例：
1.sizeof (数组名) , 这里的数组名次表示整个数组,计算的是整个数组的大小; 
2.& 数组名,这里的数组名表示的依然是整个数组;, 所以 & 数组名取出的依然是整个数组的地址



# 字符指针

```c
char* ch ="abcde";  //把字符串首字符a的地址,赋值给了p
printf("%s", ch); 
*(p + i) == p[ i ]
```


数组名通常表示的都是数组首元素的地址
但有两个特例：
1.
sizeof (数组名) , 这里的数组名次表示整个数组,计算的是整个数组的大小; 
2.
& 数组名,这里的数组名表示的依然是整个数组;, 所以 & 数组名取出的依然是整个数组的地址



### double fabs(double x);---fabs是一个函数，求绝对值。
