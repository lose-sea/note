# 位段

---

位段是可以节省空间的;

位段只能在结构体中使用

```c
struct A {
    int a : 2; 
    int b : 5; 
    int c : 10; 
    int d : 30; 
}
```

`int a : 2;`  2 表示所占的比特位

```c
struct A {
    int a : 2; 
    int b : 5; 
    int c : 10; 
    int d : 30; 
}; 
int main() {
    printf("%u\n", sizeof(struct A)); 
    return 0; 
}
```

输出: 8

占用比特位: 2 + 5 + 10 + 30 = 47; 

> 47 bit
>
> 6byte – 48 bit;
>
> 8byte – 64 bit; 

>  位段的成员可以是 int  unsigned int  signed int 或者 char (属于整形家族) 类型
>
> 位段的空间上是按照需要以 4 个字节 (int) 或者 1 个字节 (char) 的方式来开辟的. 
>
> 位段涉及很多不确定因素, 位段是不跨平台的, 注重可移植的程序应该避免使用位段



char 类型的位域是不能超过 8 ; int 类型的位域不能超过 32 ;. 

```c
struct S {
    char a : 3; 
    char b : 4; 
    char c : 5; 
    char d : 4; 
}; 
int main() {
    struct S s = {0};
    s.a = 10; // 1010
    s.b = 12; // 1100
    s.c = 3;  // 011
    s.d = 4;  // 100
    printf("%d", sizeof(struct S)); 
    return 0; 
}
```

```c
//     | 0101 | 1000 | 0011 | 0100 |
//16进制   6      4      3      4 			占用 2 个字节
//     | 0110 | 0010 | 0000 | 0100 | 0000 | 0100 |
//16进制   6      2      0      3      0      4		占用 3 个字节
```

实际输出: 3 , 表明在当前的环境下是舍弃剩余有的位的

## 位段的跨平台问题

---

1.int 位段被当成有符号数还是无符号数是不确定的。
写成27，在16位机

2.位段中最大位的数目不能确定。(16位机器最大16，32位机器最大32,
在16位机器会出问题。

3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。

4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。