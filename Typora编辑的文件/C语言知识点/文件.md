# 文件

---

长谈的文件有两种:程序文件,数据文件(从文件功能的角度来分类)

## 程序文件

> 包括源文件(后缀为.c), 目标文件(Windows环境后缀为.obj),可执行文件(windows环境后缀为.exe). 

## 数据文件

---

> 文件的内容不一定是程序,而是程序运行时读写的数据,比如程序运行需要从中读取数据的文件,或者输出内容的文件.



## 文件名

---

一个文件要有一个唯一的文件标识,以便用户识别和引用

文件名包含3个部分:文件路径 + 文件名主干 + 文件后缀

例如

> c:\code\test.txt

为了方便起见,文件标识长倍称为文件名

## 操作文件的基本过程

---

1. 打开文件
2. 读/写–操作文件
3. 关闭文件

## 文件的打开和关闭

---

### 文件指针

缓冲文件系统中,关键的概念是“文件类型指针”,简称“文件指针”.

每一个被使用的文件都在内存中开辟了一个相应的文件信息区,用来存放文件的相关信息(如文件的名字,文件状态及文件当前的位置等).这些信息是保存在一个结构体变量中.该结构体类型是有系统声明的,取名**FILE**. 

每当打开一个文件的时候,系统会根据文件的情况自动创建一个FILE结构的变量,并填充其中的信息.

一般都是通过一个FILE的指针来维护这个FILE结构的变量,这样使用起来更加方便.

`FILE* pf`文件指针变量

定义pf是一个指向FILE类型数据的指针变量.可以使pf指向某个文件的文件信息区(是一个结构体变量).通过该文件信息区中的信息就能够访问该文件.也就是说,通过文件指针变量能够找到与它关联的文件

### 文件的打开和关闭

文件在读写之前应该先打开文件,在使用结束之后应该关闭文件

在编写程序的时候,在打开文件的同时,都会返回一个FILE*的指针变量指向该文件,也相当于建立了指针和文件的关系

ANSIC 规定使用 **fopen**函数来打开文件,**fclose**来关闭文件

```c
//打开文件
FILE* fopen(const char* filename, const char* mode); 
//关闭文件
int fclose(FILE* stream); 
```

`FILE* fopen(const char* filename, const char* mode); `

filename–>文件名

mode–>文件的打开模式: 读 , 写…

| 文件使用方式 | 含义                                    | 如果文件不存在   |
| ------------ | --------------------------------------- | ---------------- |
| “r”(只读)    | 为了输入数据,打开一个已经存在的文本文件 | 出错             |
| “w”(只写)    | 为了输出数据,打开一个文本文件           | 建立一个新的文件 |
| “a”(追加)    | 向文本文件尾添加数据                    | 建立一个新的文件 |
| “rb”(只读)   | 为了输入数据,打开一个二进制文件         | 出错             |
| “wb”(只写)   | 为了输出数据,打开一个二进制文件         | 建立一个新的文件 |
| “ab”(追加)   | 向一个二进制文件尾添加数据              | 出错             |
| “r+”(读写)   | 为了读和写,打开一个二进制文件           | 出错             |
| “w+”(读写)   | 为了读和写,建议一个新的文件             | 建立一个新的文件 |
| “a+”(读写)   | 打开一个文件,在文件尾进行读写           | 建立一个新的文件 |
| “rb+”(读写)  | 为了读和写打开一个二进制文件            | 出错             |
| “wb+”(读写)  | 为了读和写,新建一个新的二进制文件       | 建立一个新的文件 |
| “ab+”(读写)  | 打开一个二进制文件,在文件尾进行读和写   | 建立一个新的文件 |

以“r”(读)的模式打开文件,该文件必须要存在.

例如: `FILE* pf = fopen(“test.txt”, “r”); `

打开失败会返回一个空指针

也可以传入文件的绝对路径

例如`FILE* pf = fopen("D:\vs code\练习\hello.c", "r")`; 

### 文件的顺序读写

---

| 功能           | 函数名  | 适用于     |
| -------------- | ------- | ---------- |
| 字符输入函数   | fgetc   | 所有输入流 |
| 字符输出函数   | fputc   | 所有输出流 |
| 文本行输入函数 | fgets   | 所有输入流 |
| 文本行输出函数 | fputs   | 所有输出流 |
| 格式化输入函数 | fscanf  | 所有输入流 |
| 格式化输出函数 | fprintf | 所有输出流 |
| 二进制输入     | fread   | 文件       |
| 二进制输出     | fwrite  | 文件       |

**fputc(int  character, FILE* strem);**

#### 写字符

`fputc('a', pf); `

向“text.txt”文件中写入26个英文字母

```c
int main() {
    FILE* pf = fopen("test.txt", "w"); 
    if (pf == NULL) {
        printf("%s\n", strerror(errno)); 
        return 1; 
    }

    // 打开成功
    // 写文件
    for (char i = 'a'; i <= 'z'; i++) {
        fputc(i, pf);
    }  // 写入字符

    // 关闭文件
    fclose(pf); //  pf 现在指向的内存已被释放
	// pf 现在是悬空指针

	pf = NULL;    // 设置为NULL，避免误用
    return 0; 
}
```



#### 读字符

int fgetc(FILE* stream); 

依次读取用fgetc读取文件中的字符，没读取一个字符，指针会自动向后移动一位

```c
int main() {
    FILE* pf = fopen("test.txt", "r"); 
    if (pf == NULL) {
        printf("%s\n", strerror(errno)); 
        return 1; 
    }
    // 打开成功
    // 读文件 
    char ch = fgetc(pf);  
    printf("%c\n", ch); 
    ch = fgetc(pf);  
    printf("%c\n", ch); 
    ch = fgetc(pf);  
    printf("%c\n", ch); 
    ch = fgetc(pf);  
    printf("%c\n", ch); 
    ch = fgetc(pf);  
    printf("%c\n", ch); 
    // 关闭文件
    fclose(pf); 
    pf = NULL; 
    return 0; 
}
```

打印

```c
a
b
c
d
e
```

```c
int main() {
    FILE* pf = fopen("text.txt", "r"); 
    if (pf == NULL) {
        printf("%s\n", strerror(errno)); 
        return 1; 
    }

    // 打开成功
    // 写文件
    int ch = 0;   
    while((ch = fgetc(pf)) != EOF) {
        printf("%c ", ch); 
    }
    // 关闭文件
    fclose(pf); 

    pf = NULL; 
    return 0; 
}
```

打印：

```c
a b c d e f g h i j k l m n o p q r s t u v w x y z
```

**每一次读写操作都会移动指针**

**rewind（pf）** 让指针回到开头; 

#### 写一行数据

int fputs(const char* str, FILE* stream); 

```c
int main() {
    FILE* pf = fopen("text.txt", "w"); 
    if (pf == NULL) {
        printf("%s\n", strerror(errno)); 
        return 1; 
    }
    // 打开成功
    // 写一行数据
    fputs("hello world", pf); 
    // 关闭文件
    fclose(pf); 

    pf = NULL; 
    return 0; 
}
```

输出:

```c
hello world
```

将字符串“hello world”写入pf所指向的文件

**在写文件时,会把文件原本的内容全部清空,然后重新写入新的内容**

*以“w”方式打开文件时文件中的数据就已经清除*

如果不想要销毁文件中原本的内容,就需要用到“a”(追加)

```c
int main() {
    FILE* pf = fopen("text.txt", "a"); 
    if (pf == NULL) {
        printf("%s\n", strerror(errno)); 
        return 1; 
    }
    // 打开成功
    // 写一行数据
    fputs("hello world", pf); 
    // 关闭文件
    fclose(pf); 

    pf = NULL; 
    return 0; 
}
```

文件中的内容就变为`hello worldhello world`

在写入数据时，需要换行，需要手动输入“\n”; 

#### 读一行数据

char* fgets(char* str, int nums, FILE* stream); 

nums–>能够返回的最大字符数

```c
int main() {
    FILE* pf = fopen("text.txt", "r"); 
    if (pf == NULL) {
        //printf("%s\n", strerror(errno));也可以写为 
        perror("fopen");   // 打印错误信息
        return 1; 
    }
    // 打开成功
    // 写一行数据
   	char arr[20]; 
    fgets(arr, 5, pf); 
    printf("%s", arr); 
    // 关闭文件
    fclose(pf); 

    pf = NULL; 
    return 0; 
}
```

打印:

```c
hell
```

实际读取了4个字符,末尾还有一个‘\0’; 

#### 写文件

---



int fprintf(FILE* stream, const char* format, …); 

int printf(const char* format, …); 

```c
struct S {
    char arr[10]; 
    int age; 
    float score; 
}; 

int main() {
    struct S s = {"xinyan", 25, 50.5}; 
    FILE* pf = fopen("test.txt", "w"); 
    if (pf == NULL) {
        perror("fopen"); 
        return 1; 
    }
    // 打开成功
    fprintf(pf, "%s %d %f", s.arr, s.age, s.score); 


    // 关闭文件
    fclose(pf); 
    pf = NULL; 
    return 0; 
}
```

将结构体的内容写入test.txt文件中

#### 读文件

int fscanf(FILE* stream, const char* format, …); 

int scanf(const char* format); 

```c
struct S {
    char arr[10]; 
    int age; 
    float score; 
}; 

int main() {
    struct S s = {0}; 
    FILE* pf = fopen("test.txt", "r"); 
    if (pf == NULL) {
        perror("fopen"); 
        return 1; 
    }
    // 打开成功
    // fprintf(pf, "%s %d %f", s.arr, s.age, s.score); 
    fscanf(pf, "%s %d %f", s.arr, &s.age, &s.score); 
    printf("%s %d %f", s.arr, s.age, s.score); 
    // 关闭文件
    fclose(pf); 
    pf = NULL; 
    return 0; 
}
```

 用fprintf将9*9乘法表打印到文件中

```c
int main() {
    FILE* pf = fopen("xinyan.txt", "w"); 
    if (pf) {
        perror ("fopen"); 
    }
    for (int i = 1; i <= 9; i++) {
        for (int j = 1; j <= i; j++) {
            fprintf(pf, "%d * %d = %-2d ", i, j, i * j); 
            printf ("%d * %d = %-2d ", i, j, i * j); 
        }
        fprintf(pf, "\n"); 
        printf("\n"); 
    }
    // 关闭文件
    fclose(pf); 
    pf = NULL; 
    return 0; 
}
```



![image-20251106184108953](C:\Users\20319\AppData\Roaming\Typora\typora-user-images\image-20251106184108953.png)

将文件中的数据读取并打印出来

![image-20251103203255707](C:\Users\20319\AppData\Roaming\Typora\typora-user-images\image-20251103203255707.png)

#### 二进制的方式写文件

size_t fwrite (const void* ptr, size_t size, size_t const, FILE* stream); 

> const void* ptr–>指向要写的数据
>
> size_t size–>每一个元素的大小
>
> size_t const–>元素的个数
>
> FILE* stream–>要写入的文件

```c
struct S {
    char arr[10]; 
    int age; 
    float score; 
}
int main() {
    struct S s = {"zhangxinyan", 25, 50.5f}; 
    FILE* pf = fopen("test.exe")
}
```

#### 二进制读数据

size_t fread( void* ptr, size_t size, size_t count, FILE* stream); 

+ void* ptr 数据类型
+  size_t size 每一个元素的大小
+ size_t count 元素的个数
+ FILE* stream 流

返回值–>成功读取的元素的个数

```c
struct S {
    char arr[10]; 
    int age; 
    float score; 
}; 

int main() {
    struct S s = {}; 
    FILE* pf = fopen("xinyan.txt", "rb"); 
    if (pf == NULL) {
        perror("fopen"); 
        return 1; 
    }
    // 打开成功
    // 二进制的方式写
    fread(&s, sizeof(struct S), 1, pf); 
    printf("%s %d %f\n", s.arr, s.age, s.score); 

    // 关闭文件
    fclose(pf); 
    pf = NULL; 
    return 0; 
}
```

## 对比一组函数

**scanf** 与 **printf**

> scanf 是针对标准输入的格式化输入语句
>
> printf 时针对标准输出的格式化输出语句

**fscanf** 与 **fprintf** 

> fscanf 是针对所有输入流的格式化输入语句
>
> fprintf 是针对所有输出流的格式化输出语句

**sscanf** 与 **sprintf**

int sscanf(const char* s, const char* format, …); 

int sprintf(char* str, const char* format, …); 

> 从一个字符串中转换出一个格式化的数据
>
> sprintf 把一个格式化的数据写到字符串中,本质是把一个格式化的数据转换成字符串

**sprintf** 演示

```c
struct S {
    char arr[10]; 
    int age; 
    float score; 
}; 

int main() {
    struct S s = {"xinyan", 20, 50.5f}; 
    char buf[100] = {0}; 
    sprintf(buf, "%s %d %f", s.arr, s.age, s.score); // 转换为字符串
    // "xinyan 20 50.500000"
    printf("%s\n", buf); 
    return 0; 
}
```

输出：

xinyan 20 50.500000

**sscanf** 演示

```c
struct S {
    char arr[10]; 
    int age; 
    float score; 
}; 

int main() {
    struct S s = {"xinyan", 20, 50.5f}; 
    char buf[100] = {0}; 
    struct S tmp = {0}; 
    sprintf(buf, "%s %d %f", s.arr, s.age, s.score); // 转换为字符串
    // 把s中的格式化数据转换成字符串放到buf中
    // "xinyan 20 50.500000" 
    printf("%s\n", buf);
    // 从字符串buf中获取一个格式化的数据到tmp中
    sscanf(buf, "%s %d %f", tmp.arr, &tmp.age, &tmp.score); 
    printf("%s %d %f", tmp.arr, tmp.age, tmp.score); 
    return 0; 
}
```

## 文件的随机读写

---

### fseek

根据文件指针的位置和偏移量来定位文件指针

int fseek(FILE* stream, long int offset. int original); 

> FILE* stream–>流
>
> long int offset–>偏移量
>
> int origin–>当前文件指针位置

fseek有三种取值

| SEEK_SET | 文件起始位置     |
| -------- | ---------------- |
| SEEK_CUR | 当前文件指针位置 |
| SEEK_END | 文件末尾         |

现在文件test.txt中数据为 abcdefg

```c
int main() {
    FILE* pf = fopen("xinyan.txt", "r"); 
    if (pf == NULL) {
        printf("%s\n", strerror(errno)); 
        return 1; 
    }
    // 文件打开成功
    // 定位文件指针
    int ch = 0; 
    fseek(pf, 2, SEEK_SET); 
    ch = fgetc(pf); 
    printf("%c\n", ch); 

    fseek(pf, 2, SEEK_CUR); // 从当前位置再向后偏移两位
    ch = fgetc(pf); 
    printf("%c\n", ch);// f

    fseek(pf, -1, SEEK_END);// 文件末尾是EOF，向前一位是g 
    ch = fgetc(pf); 
    printf("%c", ch); 
    // 关闭文件
    fclose(pf); 
    pf = NULL; 
    return 0; 
} 
```

打印:

```c
c
f
g
```

### ftell

---

求当前位置相对于起始位置的偏移量

long int ftell(FILE* stream); 

```c
int main() {
    FILE* pf = fopen("xinyan.txt", "r"); 
    if (pf == NULL) {
        printf("%s\n", strerror(errno)); 
        return 1; 
    }
    // 文件打开成功
    // 定位文件指针
    int ch = 0; 
    int p = 0; 
    fseek(pf, 2, SEEK_SET); 
    //求当前位置相对于起始位置的偏移量 
    ch = fgetc(pf); 
    printf("%c\n", ch); 
    p = ftell(pf); // 3 
    printf("%d\n", p); 
        // 关闭文件 
    fclose(pf); 
    pf = NULL; 
    return 0; 
} 
```

打印：`3`

### rewind

---

让文件指针回到文件的起始位置

void rewind(FILE* stream); 

```c
int main() {
    FILE* pf = fopen("xinyan.txt", "r"); 
    if (pf == NULL) {
        printf("%s\n", strerror(errno)); 
        return 1; 
    }
    // 文件打开成功
    // 定位文件指针
    int ch = 0; 
    int p = 0; 
    fseek(pf, 2, SEEK_SET); 
    //求当前位置相对于起始位置的偏移量 
    ch = fgetc(pf); 
    printf("%c\n", ch); 
    p = ftell(pf); // 3
    printf("%d\n", p);
    rewind(pf); // 指针回到文件开头
    ch = fgetc(pf); 
    printf("%c", ch); // a
    // 关闭文件
    fclose(pf); 
    pf = NULL; 
    return 0; 
} 
```

输出:

```c
c
3
a
```

## 文件的基本输入和输出

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE* fp;


    // 1. 写入文件
    fp = fopen("test1.txt", "w");
    if (fp == NULL) {
        perror("文件打开失败");
        return -1;
    }
    // 向文件传一个字符
    fputc('a', fp);

    // 向文件传入一个字符串
    char arr[255] = { 0 };
    scanf("%s", arr);
    fputs(arr, fp);

    // 传入26个英文字母
    char ch = 'a';
    while (ch <= 'z') {
        fputc(ch, fp);
        ch++;
    }


    fclose(fp);

    // 2. 读取文件
    fp = fopen("test.txt", "r");
    if (fp == NULL) {
        perror("文件打开失败");
        return -1;
    }

    printf("读取文件内容：\n");
    // while (fgets(arr, 255, fp) != NULL) {
    //     printf("%s", arr);
    // }

    // 读出文件
    // 创建一个字符数组来存储读出的文件
    char str[8] = { 0 };


    // while (fgets(str, 4, fp) != NULL) {
    //     printf("%s\n", str); 
    // }


    fgets(str, 5, fp);
    printf("%s", str);


    // 检查是否因错误结束
    if (ferror(fp)) {
        perror("读取文件时发生错误");
    }
    // 检查是否正常到达文件末尾
    if (feof(fp)) {
        printf("\n已到达文件末尾。\n");
    }

    fclose(fp);
    return 0;
}
```

## 向文件中传入数组和链表

---

### 传入数组

```c
#include<stdio.h>
#include<stdlib.h>
int main() {

    FILE* pf = fopen("text2.txt", "w");
    if (pf == NULL) {
        perror("fopen");
        return -1;
        
    // 文件打开成功
    // 将数组写入文件 
    // 创建一个数组
    int arr[45] = { 0 };
    for (int i = 0; i < 5; i++) { 
        scanf("%d", &arr[i]); 
    }
    fprintf(pf, "开始写入\n"); 
    for (int i = 0; i < 5; i++) { 
        fprintf(pf, "%d ", arr[i]) ; 
    }
    fprintf(pf, "\n成功将数组读入文件");
    }
    // 关闭文件
    fclose(pf);
    pf = NULL;
    return 0;
}
```

### 传入链表

---



**文本格式传入文件**

```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>

// 创建结构体类型
struct ListNode {
    int data; 
    struct ListNode* next; 
};
// 创建链表节点
// 尾插
struct ListNode* createNode(struct ListNode* head, int data) {
    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
    if (newNode == NULL) { 
        printf("内存申请失败\n"); 
        return head;
    }
    newNode->data = data; 
    newNode->next = NULL; 
    if (head == NULL) {
        return newNode; 
    }
    struct ListNode* current = head; 
    while (current->next != NULL) {
        current = current->next; 
    }
    current->next = newNode; 
    return head; 
}


int main() {

    FILE* pf = fopen("text2.txt", "w");
    if (pf == NULL) {
        perror("fopen");
        return -1;
    }
    // 文件打开成功

    //  将链表写入文件
    int count = 0; 
    struct ListNode* head = NULL; 
    // 创建节点
    for (int i = 0; i < 10; i++) { 
        head = createNode(head, i + 100); 
        count++; 
    }
    // 将节点依次写入文件
    struct ListNode* current = head;
    for (int i = 0; i < count; i++) {
        fprintf(pf, "%d\n", current->data);
        printf("%d\n", current->data); 
        current = current->next; 
    }
    printf("共写入 %d 个节点\n", count); 

    current = head; 
    while (current != NULL) {
        struct ListNode* temp = current; 
        current = current->next; 
        free(temp);
    } 
    // 关闭文件
    fclose(pf);
    pf = NULL;
    return 0;
}
```

**二进制格式传入及读取链表**

```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h> 
#include<stdlib.h>

struct ListNode {
	int data; 
	struct ListNode* next; 
};

// 尾插
struct ListNode* createNode(struct ListNode* head, int data) {
	struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
	if (newNode == NULL) {
		printf("内存申请失败\n");
		return head;
	}
	newNode->data = data;
	newNode->next = NULL;
	if (head == NULL) {
		return newNode;
	}
	struct ListNode* current = head;
	while (current->next != NULL) {
		current = current->next;
	}
	current->next = newNode;
	return head;
}


int main() {
	FILE* pf = fopen("text.txt", "wb"); 
	if (pf == NULL) {
		perror("fopen"); 
	}
	// 打开成功

	// 将链表以二进制格式传入文件
	struct ListNode* head = NULL; 
	for (int i = 0; i < 5; i++) {
		head = createNode(head, i + 5); 
	}
	struct ListNode* current = head; 
	while (current != NULL) { 
		//fputs("xinyan ", pf); 
		fwrite(current, sizeof(ListNode), 1, pf); 
		printf("%d ", current->data); 
		current = current->next; 
	} 
	printf("\n"); 

	// 关闭文件
	fclose(pf); 

	//// 二进制格式读出链表
	pf = fopen("text.txt", "rb"); 
	if (pf == NULL) {
		perror("fopen");																																													
	}
	struct ListNode temp = { 0 }; 
	while (fread(&temp, sizeof(struct ListNode), 1, pf) == 1) {
		printf("%d ", temp.data); 
	}
	

	fclose(pf); 
	while (current != NULL) { 
		struct ListNode* temp = current; 
		current = current->next; 
		free(temp); 
	}
	printf("链表已经成功以二进制的格式写入文件\n"); 
	pf = NULL; 
	return 0; 
}
```







