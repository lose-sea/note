# 排序

---

C语言中常见的排序算法可以分为以下几大类：

# 比较排序算法

O(n2) 时间复杂度

## (1) 冒泡排序 (Bubble Sort)

void bubbleSort(int arr[], int n) {
 for(int i = 0; i < n-1; i++) {
     for(int j = 0; j < n-1-i; j++) {
         if(arr[j] > arr[j+1]) {
             int temp = arr[j];
             arr[j] = arr[j+1];
             arr[j+1] = temp;
         }
     }
 }
}


特点：相邻元素比较交换，像气泡上浮
 稳定性：稳定



## (2) 选择排序 (Selection Sort)

void selectionSort(int arr[], int n) {
 for(int i = 0; i < n-1; i++) {
     int minIndex = i;
     for(int j = i+1; j < n; j++) {
         if(arr[j] < arr[minIndex]) {
             minIndex = j;
         }
     }
     int temp = arr[i];
     arr[i] = arr[minIndex];
     arr[minIndex] = temp;
 }
}

 特点：每次选择最小元素放到前面
稳定性：不稳定



## (3) 插入排序 (Insertion Sort)



void insertionSort(int arr[], int n) {
 for(int i = 1; i < n; i++) {
     int key = arr[i];
     int j = i-1;
     while(j >= 0 && arr[j] > key) {
         arr[j+1] = arr[j];
         j--;
     }
     arr[j+1] = key;
 }
}


 特点：像打扑克牌一样插入元素
 稳定性：稳定
 适用：小数据量或基本有序的数据
O(n log n) 时间复杂度

## (4) 快速排序 (Quick Sort)


void quickSort(int arr[], int low, int high) {
 if(low < high) {
     int pi = partition(arr, low, high);
     quickSort(arr, low, pi-1);
     quickSort(arr, pi+1, high);
 }
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for(int j = low; j < high; j++) {
        if(arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i+1];
    arr[i+1] = arr[high];
    arr[high] = temp;
    return i+1;
}

 特点：分治思想，实际应用中最快
 稳定性：不稳定
 时间复杂度：平均O(n log n)，最坏O(n2)

## (5) 归并排序 (Merge Sort)

void mergeSort(int arr[], int left, int right) {
    if(left < right) {
        int mid = left + (right-left)/2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid+1, right);
        merge(arr, left, mid, right);
    }
}

void merge(int arr[], int left, int mid, int right) {
    // 合并两个有序数组
}

 特点：分治思想，需要额外空间
 稳定性：稳定
时间复杂度：始终O(n log n)

## (6) 堆排序 (Heap Sort)

void heapSort(int arr[], int n) {
    // 建堆
    for(int i = n/2-1; i >= 0; i--)
        heapify(arr, n, i);
    // 排序
    for(int i = n-1; i > 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        heapify(arr, i, 0);
    }
}

void heapify(int arr[], int n, int i) {
    // 调整堆
}


特点：利用堆数据结构
稳定性：不稳定

#  非比较排序算法

O(n) 时间复杂度

## (7) 计数排序 (Counting Sort)


void countingSort(int arr[], int n) {
 int max = arr[0];
 for(int i = 1; i < n; i++)
     if(arr[i] > max) max = arr[i];

 int count[max+1];
 // 统计频率、累加、排序
}

适用：数据范围不大的整数
 稳定性：稳定

## (8) 桶排序 (Bucket Sort)

 将数据分到多个桶中，每个桶单独排序
适用：数据均匀分布的情况

## (9) 基数排序 (Radix Sort)

void radixSort(int arr[], int n) {
 int max = getMax(arr, n);
 for(int exp = 1; max/exp > 0; exp *= 10)
     countSort(arr, n, exp);
}

 特点：按位数排序
 适用：整数排序，位数不多的情况
稳定性：稳定