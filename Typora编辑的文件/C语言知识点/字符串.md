# strlen

----

## 模拟实现

```c
//求字符串长度
size_t Mystrlen (const char* str) {
	size_t count = 0; 
	assert(str); 
	while (*str != '\0') {
		count++; 
		str++; 
	}
	return count; 
}
int main() {
	char ch[] = "abcde";
	int len = Mystrlen(ch); 
	printf("%u\n", len); 
	return 0; 
}
```



**strlen 的返回值类型是 size_t(无符号整型)**



# strcpy

---

strcpy (char* destinaion, const char* source)

将字符串 course 中的内容拷贝到 字符串 destina 中,(包括 ‘\0’); 

```c
int main() {
	char ch[] = "zhangsan"; 
	strcpy(ch, "liu"); 
	//ch = "liu";  err
	printf("%s", ch); 
	return 0; 
}
```

输出:

```c
liu
```

## 注意事项

> 源字符串必须以‘\0’结束.
>
> 会将源字符串中的‘\0’拷贝到目标空间.
>
> 目标必须足够大,以确保能存放源字符串.
>
> 目标空间必须可变

## 模拟实现

+ 

```c
void My_strcpy(char* destination, char* source) {
    assert(destination); 如果destination 为NULL则会报错
    assert(source);     
	int len = strlen(source); 
	int i = 0; 
	for (i = 0; i < len; i++) {
		destination[i] = source[i]; 
	}
	destination[len] = '\0'; 
}
int main() {
	char ch[] = "abcde"; 
	char arr[] = "efg"; 
	My_strcpy(ch, arr); 
	printf("%s", ch); 
	return 0; 
}      //改变了strcpy的功能
```

+ 

```c
#include<stdio.h>
#include<string.h>
#include<assert.h>
char* My_strcpy(char* destina, char* source) {
    assert(source && destina);  
    char* remain = destina; 
    while (*destina++ = *source++) {
         ;
    } 
    return remain; 
}
int main() {
	char ch[] = "abcde"; 
	char arr[] = "xin"; 
	My_strcpy(ch, arr); 
	printf("%s", ch); 
	return 0; 
}
```



# strcat

+++

strcat (char* destinaion, const char* source)

字符串追加

```c
int main() {
    char arr[20] = "hello "; 
    strcat(arr, "world!"); 
    printf("%s", arr); 
    return 0; 
}
```

输出`hello world`

## 注意事项

> 源字符串必须以 ‘\0’ 结束; 
>
> 目标空间必须足够大, 能容纳下源字符串的内容
>
> 目标空间必须可修改

## 模拟实现

```c
char* My_strcat(char* destina, const char* source) {
    char* remain = destina; 
    while(*destina) {
        destina++;
    }  //先找到空间的末尾
    while(*destina++ = *source++) {
        ;
    }  //拷贝字符串
    return remain; 
}
int main() {
    char arr[20] = "hello "; 
    //strcat(arr, "world!"); 
    My_strcat(arr, "world"); 
    printf("%s", arr); 
    return 0; 
}
```



# strcmp函数

+++

函数原型：int strcmp (const char *s1, const char *s2);

比较两个字符串是否相等

功能：比较两个字符串s1和s2。
返回值：

如果s1小于s2，返回一个负整数。
如果s1等于s2，返回 0。
如果s1大于s2，返回一个正整数。 

## 比较原理

strcmp函数是按照字符的 ASCII 码值逐个比较两个字符串中的字符。
从两个字符串的第一个字符开始比较。
当遇到不相等的字符时，返回这两个字符 ASCII 码值的差值。
如果比较到某一个字符串结束（即遇到'\0'）还未发现不同字符，则根据两个字符串的长度来判断大小：
如果s1的长度小于s2的长度，则s1小于s2。
如果s1的长度大于s2的长度，则s1大于s2。
如果s1和s2长度相同，则s1等于s2。

strcmp 比较两个字符串时，遵循 “从左到右逐个字符对比，以第一个不相等的字符的 ASCII 码差值
作为结果” 的规则，与后续字符的大小无关。

## 模拟实现:



```c
int My_strcmp(const char* str1, const char* str2) {
    assert(str1 && str2); 
    while (*str1 == *str2) {
        if(*str1 == '\0') {
            return 0; 
        }
        str1++; 
        str2++; 
    }
   return *str1 - *str2; 
}
int main() {
    char arr1[20] = "abcdef"; 
    char arr2[] = "abq"; 
    int ret = My_strcmp(arr1, arr2); 
    if (ret == 0) {
        printf("==\n"); 
    } else if (ret < 0) {
        printf("<\n"); 
    } else {
        printf(">\n"); 
    }
    return 0; 
}
```



# strstr

---

const char* strstr ( const char* str1, const char* str2); 

char* strstr (char* str1, char str2); 

查找子串的函数

## 模拟实现

-----

```c
char* My_strstr(const char* str1, const char* str2) {
    assert(str1 && str2);
    if (*str2 == '\0') {
        return (char*)str1; 
    } 
    int i = 0; 
    const char* p = str1; 
    int len1 = strlen(str1); 
    int len2 = strlen(str2); 
    while (i <= len1 - len2) {
        const char* s1 = p; 
        const char* s2 = str2; 
        int j = 0; 
        for (j = 0;j < len2; j++) {
            if (s1[j] != s2[j]) {
                p++; 
                break; 
            }
        }
        if (j == len2) {
            return (char*)p; 
        }
        i++; 
    }
    return NULL; 
}
int main() {
    char arr[20] = "zhangxinyan"; 
    char* ret = My_strstr(arr, "xin"); 
    if (ret == NULL) {
        printf("No"); 
    } else {
        printf("%s", ret); 
    }
    return 0; 
}
```



# strtok

----

char* strtok ( char * str, const sep); 

+ srt 参数是个字符串, 定义了用作分隔符的字符集合

+ 第一个参数指定一个字符串, 它包含 0 个或者多个有sep字符中一个或者多个分隔符分割的标记. 

+ strtok 函数找到str 中的下一个标记,并将其用 ‘\0’, 结尾, 返回这一个指向的临时标记.

  > strtok函数会改变被操作的字符串, 所以在使用strtok函数切分字符串一般都是临时拷贝的内容并且可修改.

+ strtok函数的第一个参数不为NULL, 函数将找到str中的第一个标记, strtok函数将保存它在字符串中的位置
+ strtok函数的第一个参数为NULL, 函数将在同一个字符中被保存的位置开始,查找下一个标记.
+ 如果字符串不存在更多的标记,则返回NULL指针

```c
int main() {
    char arr[] = "zhang.xin yan"; 
    char sep[] = ". "; 
    char cp[20] = {0}; 
    strcpy(cp, arr); 

    char* ret = strtok(arr, sep); 
    printf("%s\n", ret); 

    ret = strtok(NULL, sep); 
    printf("%s\n", ret); 
    
    ret = strtok(NULL, sep);
    printf("%s\n", ret); 
    return 0; 
}
```



# strerror

----

char* strerrpr (int errnum); 

错误报告函数,返回错误码,所对应的错误信息

```c
int main() {
    printf("%s\n", strerror(0)); 
    printf("%s\n", strerror(1)); 
    printf("%s\n", strerror(2)); 
    printf("%s\n", strerror(3)); 
    return 0; 
}
```

输出:

```c
No error
Operation not permitted
No such file or directory
No such process
```



# toupper函数 tolower函数

----

int tower( int c);   转大写

int touper (int c);   转小写



```c
#include<ctype.h>
int main() {
    printf("%c\n", tolower('D')); 
    printf("%c\n", toupper('c')); 
    printf("%c\n", toupper('@')); 
    return 0; 
}
```

输出:

```c
d
C
@
```

如果不是大写字母或者小写字母, 则不会改变

# memcpy

---

void* memcpy (void* destination, const void* siurce, size_t num); 

+  函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置
+ 这个函数在遇到‘\0’的时候并不会停下来
+ 如果source 和 destination有任何的重叠, 复制的结果都是未定义的.

```c
int main() {
    int arr[] = {1,2,3,4,5,6,7,8,9};
    int brr[20] = {0}; 
    memcpy (brr, arr, 28); 
    int i = 0; 
    while(brr[i] != '\0') {
        printf("%d ", brr[i]); 
        i++; 
    }
    return 0; 
}
```

输出:

```c
1,2,3,4,5,6,7
```

## 模拟实现

```c
void* My_memcpy(void* dest, void* sou, size_t num) {
    assert(dest && sou); 
    void* ret = dest;  
    while (num--) {
        *(char*)dest = *(char*)sou; 
        sou = (char*)sou + 1; 
        dest = (char*)dest + 1; 
    }
    return ret; 
}
int main() {
    int arr[] = {1,2,3,4,5,6,7,8,9};
    int brr[20] = {0}; 
    My_memcpy (brr, arr, 28); 
    for (int i = 0; i < 7; i++) {
        printf("%d ", brr[i]); 
    }
    return 0; 
}
```

memcpy 负责拷贝两块独立空间中的数据

重叠内存的拷贝,使用  memmove



# 长度受限制的函数

---

## strncpy

---

+ strncpy    char * strncpy ( char * destination, const char * source, size_t num); 

替换指定长度的字符串

```c
int main() {
    char arr[20] = "hello world"; 
    strncpy (arr, "xinyan", 3); 
    printf("%s", arr); 
    return 0; 
}
```

输出:

`xinlo world`

## 模拟实现

```c
char* My_strncpy(char* destina, const char* source, int len) {
    assert (destina && source); 
    int i = 0; 
    for (i = 0; i < len && source[i] != '\0'; i++) {
        destina[i] = source[i]; 
    } 
    return destina; 
}
int main() {
    char arr[20] = "hello world"; 
    My_strncpy(arr, "xinyan", 3); 
    printf("%s", arr); 
    return 0; 
}
```



## strncat

---

+ strncat    char * strncat ( char * destination, const char * source, size_t num); 

追加指定长度的字符串

```c
int main() {
    char arr[20] = "hello world "; 
    strncat (arr, "xinyan", 3); 
    printf("%s", arr); -
    return 0; 
}
```

输出:

```c
hello world xin
```

## 模拟实现

```c
char* My_strncat(char* destina, const char* sou, int len) {
    assert(destina && sou); 
    char* tem = destina; 
    while (*tem != '\0') {
        tem++; 
    } 
    int i = 0; 
    for (i = 0; i < len && sou[i] != '\0'; i++) {
        tem[i] = sou[i]; 
    }
    tem[i] = '\0'; 
    return destina; 
}
int main() {
    char arr[20] = "hello world "; 
    My_strncat(arr, "xinyan", 3); 
    printf("%s", arr); 
    return 0; 
}
```



# strncmp

---

+ strncmp    char * strncmp (const char * destination,  const char * source, size_t num); 

比较两个字符串是否相等

```c
int main() {
    char arr1[20] = "abcde"; 
    char arr2[] = "abc"; 
    int ret = strncmp(arr1, arr2, 3); 
    if (ret  < 0) {
        printf("<"); 
    } else if (ret > 0) {
        printf(">"); 
    } else {
        printf("=="); 
    }
    return 0; 
}
```

输出:

==

## 模拟实现

```c
int My_strncmp(const char* arr1, const char* arr2, int len) {
    int i = 0; 
    while(i < len) {
        if (*arr1 == *arr2) {
            if (*arr1 == '\0' ) {
                return 0; 
            }
        } else {
            return *arr1 - *arr2; 
        } 
        arr1++;
        arr2++; 
        i++; 
    }
    return 0; 
}
int main() {
    char arr1[] = "abcde"; 
    char arr2[] = "abc"; 
    int ret = My_strncmp(arr1, arr2, 3); 
    if (ret < 0) {
        printf("<"); 
    } else if (ret > 0) {
        printf(">"); 
    } else {
        printf ("=="); 
    }
    return 0; 
}
```

