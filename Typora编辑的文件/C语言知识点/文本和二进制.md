# 文本文件和二进制文件

---

根据数据的组织形式，数据文件被称为**文本文件**或者**二进制文件**

数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件

如果要求在外存上以ASCLL码的形式存储，则需要在存储前转换。以ASCLL字符的形式存储的文件就是文本文件。

数据在内存中是怎么存储的呢？

字符一律以ASCLL形式存储,数值型数据既可以用ASCLL形式存储,也可以使用二进制形式存储.

例如：10000在内存中

以字符的形式存储:

``` c
'1' '0' '0' '0' '0'-->占用五个字节
```

以二进制的形式存储:

```c
10 27 00 00  -->占用四个字节
```

![image-20251106191152649](C:\Users\20319\AppData\Roaming\Typora\typora-user-images\image-20251106191152649.png)

# 文件读取结束的判定

---

## 被错误使用的feof

在文件读取的过程中，不能用feof函数的返回值直接用来判断文件的是否结束，而是应用于当文件读取结束结束的时候，判断是读取失败结束，还是遇到文件尾结束



1. 文本文件读取是否结束，判断返回值是否为EOF(fgetc), 或者NULL(fgets)

+ fgetc判断是否为EOF; 
+ fgets判断返回值是否为NULL; 

2. 二进制文件的读取结束判断,判断返回值是否小于实际要读的个数

+ fread判断返回值是否小于实际要读的个数

> size_t fread(void* ptr,  size_t size,  size_t count); 
>
> ```c
> size_t size-->需要读取的元素的个数
> ```
>
> 返回成功读取的元素的个数

feof–>判断是否读取到文件末尾

> 如果到达文件末尾就返回0
>
> 返回非零值表示已经到达文件的末尾

ferror–>判断读取是否发生错误

> 如果读取发生错误就返回非零值
>
> 没有发生错误则返回0

 判断文件是否读取结束还是读取错误

```c
int main() {
    FILE *file = fopen("test.txt", "r");
    if (file == NULL) {
        perror("打开文件失败");
        return 1;
    }
    int ch; 
    // 错误用法：用 feof 作为循环条件
    while (!feof(file)) {
        ch = fgetc(file);
        // 这里可能会多读一次！
    }

    // 正确用法1：先读取再判断
    while ((ch = fgetc(file)) != EOF) {
        putchar(ch);
    }
    
    if (feof(file)) {
        printf("\n正常到达文件末尾\n");
    } else if (ferror(file)) {
        printf("\n读取时发生错误\n");
    }

    // 正确用法2：读取后立即检查
    rewind(file); // 回到文件开头
    
    char buffer[100];
    while (fgets(buffer, sizeof(buffer), file) != NULL) {
        printf("%s", buffer);
    }
    
    if (feof(file)) {
        printf("成功读取完整文件\n");
    }

    fclose(file);
    return 0;
}
```



# 文件缓冲区

---

ASCLL 标准采用“缓冲文件系统”处理的数据文件的,所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”,从内存向磁盘输出数据会先送到内存中的缓冲区,装满缓冲区后才一起送到磁盘上,如果从磁盘向计算机读入数据,则从磁盘文件中读取数据输入到内存缓冲区(充满缓冲区), 然后再从缓冲区逐个地将数据送到程序数据区(程序变量等),缓冲地大小根据C编译系统决定地.

![image-20251105003908919](C:\Users\20319\AppData\Roaming\Typora\typora-user-images\image-20251105003908919.png)

```c
int main() {
	FILE* pf = fopen("test.txt", "w"); 
	fputs("abcdef", pf); 
	printf("睡眠10秒钟-已经写数据了，打开test。txt文件，发现文件没有内容\n"); 
	Sleep(10000); 
	printf("刷新缓冲区\n"); 
	fflush(pf); // 刷新缓冲区时,才将输出缓冲区的数据写到文件(磁盘)
	printf("再睡眠10秒,此时,再次打开text.txt文件,文件有内容了\n"); 
	Sleep(10000); 
	fclose(pf); 
	// fclose在关闭文件的时候,也会刷新缓冲区
	pf = NULL; 
}
```

